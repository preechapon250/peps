
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>PEP 827 – Type Manipulation | peps.python.org</title>
    <link rel="shortcut icon" href="../_static/py.png">
    <link rel="canonical" href="https://peps.python.org/pep-0827/">
    <link rel="stylesheet" href="../_static/style.css" type="text/css">
    <link rel="stylesheet" href="../_static/mq.css" type="text/css">
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" media="(prefers-color-scheme: light)" id="pyg-light">
    <link rel="stylesheet" href="../_static/pygments_dark.css" type="text/css" media="(prefers-color-scheme: dark)" id="pyg-dark">
    <link rel="alternate" type="application/rss+xml" title="Latest PEPs" href="https://peps.python.org/peps.rss">
    <meta property="og:title" content='PEP 827 – Type Manipulation | peps.python.org'>
    <meta property="og:description" content="We propose to add powerful type-level introspection and construction facilities to the type system, inspired in large part by TypeScript’s conditional and mapped types, but adapted to the quite different conditions of Python typing.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://peps.python.org/pep-0827/">
    <meta property="og:site_name" content="Python Enhancement Proposals (PEPs)">
    <meta property="og:image" content="https://peps.python.org/_static/og-image.png">
    <meta property="og:image:alt" content="Python PEPs">
    <meta property="og:image:width" content="200">
    <meta property="og:image:height" content="200">
    <meta name="description" content="We propose to add powerful type-level introspection and construction facilities to the type system, inspired in large part by TypeScript’s conditional and mapped types, but adapted to the quite different conditions of Python typing.">
    <meta name="theme-color" content="#3776ab">
</head>
<body>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-sun-half" viewBox="0 0 24 24" pointer-events="all">
    <title>Following system colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="9"></circle>
      <path d="M12 3v18m0-12l4.65-4.65M12 14.3l7.37-7.37M12 19.6l8.85-8.85"></path>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected dark colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24" pointer-events="all">
    <title>Selected light colour scheme</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
         stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
</svg>
    <script>

        document.documentElement.dataset.colour_scheme = localStorage.getItem("colour_scheme") || "auto"
    </script>
    <section id="pep-page-section">
        <header>
            <h1 data-pagefind-ignore>Python Enhancement Proposals</h1>
            <ul class="breadcrumbs">
                <li><a href="https://www.python.org/" title="The Python Programming Language">Python</a> &raquo; </li>
                <li><a href="../pep-0000/">PEP Index</a> &raquo; </li>
                <li>PEP 827</li>
            </ul>
            <button id="colour-scheme-cycler" onClick="setColourScheme(nextColourScheme())">
                <svg aria-hidden="true" class="colour-scheme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-dark"><use href="#svg-moon"></use></svg>
                <svg aria-hidden="true" class="colour-scheme-icon-when-light"><use href="#svg-sun"></use></svg>
                <span class="visually-hidden">Toggle light / dark / auto colour theme</span>
            </button>
        </header>
        
        <div id="mobile-search" class="mobile-search-container"></div>
        
        <article data-pagefind-body>
            
            <span data-pagefind-meta="title:PEP 827 – Type Manipulation" data-pagefind-weight="10" class="visually-hidden">PEP 827 – Type Manipulation</span>
            <section id="pep-content">
<h1 class="page-title">PEP 827 – Type Manipulation</h1>
<dl class="rfc2822 field-list simple">
<dt class="field-odd">Author<span class="colon">:</span></dt>
<dd class="field-odd">Michael J. Sullivan &lt;sully&#32;&#97;t&#32;vercel.com&gt;,
Daniel W. Park &lt;daniel.park&#32;&#97;t&#32;vercel.com&gt;,
Yury Selivanov &lt;yury&#32;&#97;t&#32;vercel.com&gt;</dd>
<dt class="field-even">Discussions-To<span class="colon">:</span></dt>
<dd class="field-even">Pending</dd>
<dt class="field-odd">Status<span class="colon">:</span></dt>
<dd class="field-odd"><abbr title="Proposal under active discussion and revision">Draft</abbr></dd>
<dt class="field-even">Type<span class="colon">:</span></dt>
<dd class="field-even"><abbr title="Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem">Standards Track</abbr></dd>
<dt class="field-odd">Topic<span class="colon">:</span></dt>
<dd class="field-odd"><a class="reference external" href="../topic/typing/">Typing</a></dd>
<dt class="field-even">Created<span class="colon">:</span></dt>
<dd class="field-even">27-Feb-2026</dd>
<dt class="field-odd">Python-Version<span class="colon">:</span></dt>
<dd class="field-odd">3.15</dd>
<dt class="field-even">Post-History<span class="colon">:</span></dt>
<dd class="field-even">Pending</dd>
</dl>
<hr class="docutils" />
<section id="contents">
<details><summary>Table of Contents</summary><ul class="simple">
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#prisma-style-orms">Prisma-style ORMs</a></li>
<li><a class="reference internal" href="#automatically-deriving-fastapi-crud-models">Automatically deriving FastAPI CRUD models</a></li>
<li><a class="reference internal" href="#dataclasses-style-method-generation">dataclasses-style method generation</a></li>
<li><a class="reference internal" href="#more-powerful-decorator-typing">More powerful decorator typing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification-of-some-prerequisites">Specification of Some Prerequisites</a><ul>
<li><a class="reference internal" href="#unpack-of-typevars-for-kwargs">Unpack of typevars for <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code></a></li>
<li><a class="reference internal" href="#extended-callables">Extended Callables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#grammar-specification-of-the-extensions-to-the-type-language">Grammar specification of the extensions to the type language</a><ul>
<li><a class="reference internal" href="#type-booleans">Type booleans</a></li>
<li><a class="reference internal" href="#conditional-types">Conditional types</a></li>
<li><a class="reference internal" href="#unpacked-comprehension">Unpacked comprehension</a></li>
<li><a class="reference internal" href="#type-member-access">Type member access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-operators">Type operators</a><ul>
<li><a class="reference internal" href="#boolean-operators">Boolean operators</a></li>
<li><a class="reference internal" href="#basic-operators">Basic operators</a></li>
<li><a class="reference internal" href="#union-processing">Union processing</a></li>
<li><a class="reference internal" href="#object-inspection">Object inspection</a></li>
<li><a class="reference internal" href="#object-creation">Object creation</a></li>
<li><a class="reference internal" href="#initfield">InitField</a></li>
<li><a class="reference internal" href="#callable-inspection-and-creation">Callable inspection and creation</a></li>
<li><a class="reference internal" href="#generic-callable">Generic Callable</a></li>
<li><a class="reference internal" href="#overloaded-function-types">Overloaded function types</a></li>
<li><a class="reference internal" href="#raise-error">Raise error</a></li>
<li><a class="reference internal" href="#update-class">Update class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lifting-over-unions">Lifting over Unions</a></li>
<li><a class="reference internal" href="#runtime-evaluation-support">Runtime evaluation support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-tutorial">Examples / Tutorial</a><ul>
<li><a class="reference internal" href="#pep827-qb-impl">Prisma-style ORMs</a></li>
<li><a class="reference internal" href="#pep827-fastapi-impl">Automatically deriving FastAPI CRUD models</a></li>
<li><a class="reference internal" href="#pep827-init-impl">dataclasses-style method generation</a></li>
<li><a class="reference internal" href="#numpy-style-broadcasting">NumPy-style broadcasting</a><ul>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#pep827-callable-rationale">Extended Callables</a></li>
<li><a class="reference internal" href="#pep827-generic-callable-rationale">Generic Callable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#alternate-syntax-ideas">Alternate syntax ideas</a><ul>
<li><a class="reference internal" href="#dictionary-comprehension-based-syntax-for-creating-typed-dicts-and-protocols">Dictionary comprehension based syntax for creating typed dicts and protocols</a><ul>
<li><a class="reference internal" href="#destructuring">Destructuring?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#call-type-operators-using-parens">Call type operators using parens</a></li>
<li><a class="reference internal" href="#have-a-general-mechanism-for-dot-notation-accessible-associated-types">Have a general mechanism for dot-notation accessible associated types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#renounce-all-cares-of-runtime-evaluation">Renounce all cares of runtime evaluation</a></li>
<li><a class="reference internal" href="#support-typescript-style-pattern-matching-in-subtype-checking">Support TypeScript style pattern matching in subtype checking</a></li>
<li><a class="reference internal" href="#replace-isassignable-with-something-weaker-than-assignable-to-checking">Replace <code class="docutils literal notranslate"><span class="pre">IsAssignable</span></code> with something weaker than “assignable to” checking</a></li>
<li><a class="reference internal" href="#don-t-use-dot-notation-to-access-member-components">Don’t use dot notation to access <code class="docutils literal notranslate"><span class="pre">Member</span></code> components</a></li>
<li><a class="reference internal" href="#use-type-operators-for-conditional-and-iteration">Use type operators for conditional and iteration</a></li>
<li><a class="reference internal" href="#perform-type-manipulations-with-normal-python-functions">Perform type manipulations with normal Python functions</a></li>
<li><a class="reference internal" href="#make-the-type-level-operations-more-strictly-typed">Make the type-level operations more “strictly-typed”</a></li>
</ul>
</li>
<li><a class="reference internal" href="#potential-future-extensions">Potential Future Extensions</a><ul>
<li><a class="reference internal" href="#support-manipulating-annotated">Support Manipulating Annotated</a><ul>
<li><a class="reference internal" href="#string-manipulation">String manipulation</a></li>
<li><a class="reference internal" href="#newprotocolwithbases">NewProtocolWithBases</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>
</details></section>
<section id="abstract">
<h2><a class="toc-backref" href="#abstract" role="doc-backlink">Abstract</a></h2>
<p>We propose to add powerful type-level introspection and construction
facilities to the type system, inspired in large part by
TypeScript’s conditional and mapped types, but adapted to the quite
different conditions of Python typing.</p>
</section>
<section id="motivation">
<h2><a class="toc-backref" href="#motivation" role="doc-backlink">Motivation</a></h2>
<p>Python has a gradual type system, but at the heart of it is a <em>fairly</em>
conventional static type system.</p>
<p>In Python as a language, on the other hand, it is not unusual to
perform complex metaprogramming, especially in libraries and
frameworks. The type system typically cannot model metaprogramming.</p>
<p>To bridge the gap between metaprogramming and the type
system, some libraries come with custom mypy plugins.
The case of dataclass-like transformations
was considered common enough that a special-case
<code class="docutils literal notranslate"><span class="pre">&#64;dataclass_transform</span></code> decorator was added specifically to cover
that case (<a class="pep reference internal" href="../pep-0681/" title="PEP 681 – Data Class Transforms">PEP 681</a>). The problem with this approach is that many
typecheckers do not (and will not) have a plugin API, so having
consistent typechecking across IDEs, CI, and tooling is not
achievable.</p>
<p>Given the significant mismatch between the expressiveness of
the Python language and its type system, we propose to bridge
this gap by adding type manipulation facilities that
are better able to keep up with dynamic Python code.</p>
<p>There is demand for this. In the analysis of the
responses to Meta’s <a class="reference external" href="https://engineering.fb.com/2025/12/22/developer-tools/python-typing-survey-2025-code-quality-flexibility-typing-adoption/">2025 Typed Python Survey</a>, the first
entry on the list of “Most Requested Features” was:</p>
<blockquote>
<div><strong>Missing Features From TypeScript and Other Languages</strong>: Many respondents
requested features inspired by TypeScript, such as <strong>Intersection types</strong>
(like the &amp; operator), <strong>Mapped and Conditional types</strong>, <strong>Utility types</strong>
(like Pick, Omit, keyof, and typeof), and better <strong>Structural typing</strong> for
dictionaries/dicts (e.g., more flexible TypedDict or anonymous types).</div></blockquote>
<p>We will present a few examples of problems that could be solved with
more powerful type manipulation, but the proposal is generic and will
unlock many more use cases.</p>
<section id="prisma-style-orms">
<h3><a class="toc-backref" href="#prisma-style-orms" role="doc-backlink">Prisma-style ORMs</a></h3>
<p><a class="reference external" href="https://www.prisma.io/">Prisma</a>, a popular ORM for TypeScript, allows writing
database queries in TypeScript like
(adapted from <a class="reference external" href="https://github.com/prisma/prisma-examples/tree/latest/orm/express">this example</a>):</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">prisma</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">findMany</span><span class="p">({</span>
<span class="w">  </span><span class="nx">select</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">true</span><span class="p">,</span>
<span class="w">    </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="kt">true</span><span class="p">,</span>
<span class="w">    </span><span class="nx">posts</span><span class="o">:</span><span class="w"> </span><span class="kt">true</span><span class="p">,</span>
<span class="w">  </span><span class="p">},</span>
<span class="p">});</span>
</pre></div>
</div>
<p>for which the inferred type of <code class="docutils literal notranslate"><span class="pre">user</span></code> will be something like:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">    </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="nx">posts</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>
<span class="w">        </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">        </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="nx">authorId</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="p">}[];</span>
<span class="p">}[]</span>
</pre></div>
</div>
<p>Here, the output type is an intersection of the existing information
about the type of <code class="docutils literal notranslate"><span class="pre">prisma.user</span></code> (a TypeScript type reflected from
the database <code class="docutils literal notranslate"><span class="pre">user</span></code> table) and the type of the argument to
the <code class="docutils literal notranslate"><span class="pre">findMany()</span></code> method. It returns an array of objects containing
the properties of <code class="docutils literal notranslate"><span class="pre">user</span></code> that were explicitly requested;
where <code class="docutils literal notranslate"><span class="pre">posts</span></code> is a “relation” referencing another type.</p>
<p>We would like to be able to do something similar in Python. Suppose
our database schema is defined in Python (or code-generated from
the database) like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Comment</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">poster</span><span class="p">:</span> <span class="n">Link</span><span class="p">[</span><span class="n">User</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Post</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="n">title</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">content</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="n">comments</span><span class="p">:</span> <span class="n">MultiLink</span><span class="p">[</span><span class="n">Comment</span><span class="p">]</span>
    <span class="n">author</span><span class="p">:</span> <span class="n">Link</span><span class="p">[</span><span class="n">User</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">User</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="n">name</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">email</span><span class="p">:</span> <span class="n">Property</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">posts</span><span class="p">:</span> <span class="n">Link</span><span class="p">[</span><span class="n">Post</span><span class="p">]</span>
</pre></div>
</div>
<p>So, in Python code, a call like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">db</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
    <span class="n">User</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">email</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">posts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>would have a dynamically computed return type <code class="docutils literal notranslate"><span class="pre">list[&lt;User&gt;]</span></code> where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class &lt;User&gt;:
    name: str
    email: str
    posts: list[&lt;Post&gt;]

class &lt;Post&gt;:
    id: int
    title: str
    content: str
</pre></div>
</div>
<p>Even further, an IDE could offer code completion for
all arguments of the <code class="docutils literal notranslate"><span class="pre">db.select()</span></code> call (matching the
actual database column names), recursively.</p>
<p>(Example code for implementing this <a class="reference internal" href="#pep827-qb-impl"><span class="std std-ref">below</span></a>.)</p>
</section>
<section id="automatically-deriving-fastapi-crud-models">
<h3><a class="toc-backref" href="#automatically-deriving-fastapi-crud-models" role="doc-backlink">Automatically deriving FastAPI CRUD models</a></h3>
<p>The <a class="reference external" href="https://fastapi.tiangolo.com/tutorial/sql-databases/#heroupdate-the-data-model-to-update-a-hero">FastAPI tutorial</a>, shows how to
build CRUD endpoints for a simple <code class="docutils literal notranslate"><span class="pre">Hero</span></code> type.  At its heart is a
series of class definitions used both to define the database interface
and to perform validation and filtering of the data in the endpoint:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HeroBase</span><span class="p">(</span><span class="n">SQLModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Hero</span><span class="p">(</span><span class="n">HeroBase</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">secret_name</span><span class="p">:</span> <span class="nb">str</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HeroPublic</span><span class="p">(</span><span class="n">HeroBase</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HeroCreate</span><span class="p">(</span><span class="n">HeroBase</span><span class="p">):</span>
    <span class="n">secret_name</span><span class="p">:</span> <span class="nb">str</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HeroUpdate</span><span class="p">(</span><span class="n">HeroBase</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">secret_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">HeroPublic</span></code> type is used as the return type of the read
endpoint (and is validated while being output, including having extra
fields stripped), while <code class="docutils literal notranslate"><span class="pre">HeroCreate</span></code> and <code class="docutils literal notranslate"><span class="pre">HeroUpdate</span></code> serve as
input types (automatically converted from JSON and validated based on
the types, using <a class="reference external" href="https://docs.pydantic.dev/latest/">Pydantic</a>).</p>
<p>Despite the multiple types and duplication here, mechanical rules
could be written for deriving these types:</p>
<ul class="simple">
<li>The “Public” version should include all non-“hidden” fields, and the primary key
should be made non-optional</li>
<li>“Create” should include all fields except the primary key</li>
<li>“Update” should include all fields except the primary key, but they
should all be made optional and given a default value</li>
</ul>
<p>With the definition of appropriate helpers inside FastAPI framework,
this proposal would allow its users to write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Hero</span><span class="p">(</span><span class="n">NewSQLModel</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">secret_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">hidden</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">type</span> <span class="n">HeroPublic</span> <span class="o">=</span> <span class="n">Public</span><span class="p">[</span><span class="n">Hero</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">HeroCreate</span> <span class="o">=</span> <span class="n">Create</span><span class="p">[</span><span class="n">Hero</span><span class="p">]</span>
<span class="nb">type</span> <span class="n">HeroUpdate</span> <span class="o">=</span> <span class="n">Update</span><span class="p">[</span><span class="n">Hero</span><span class="p">]</span>
</pre></div>
</div>
<p>Those types, evaluated, would look something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HeroPublic</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HeroCreate</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">secret_name</span><span class="p">:</span> <span class="nb">str</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HeroUpdate</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">secret_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
<p>While the implementation of <code class="docutils literal notranslate"><span class="pre">Public[]</span></code>, <code class="docutils literal notranslate"><span class="pre">Create[]</span></code>, and <code class="docutils literal notranslate"><span class="pre">Update[]</span></code>
computed types is relatively complex, they perform quite mechanical
operations and if included in the framework library they would significantly
reduce the boilerplate the users of FastAPI have to maintain.</p>
<p>A notable feature of this use case is that it <strong>requires performing
runtime evaluation of the type annotations</strong>. FastAPI uses the
Pydantic models to validate and convert to/from JSON for both input
and output from endpoints.</p>
<p>Currently it is possible to do the runtime half of this: we could write
functions that generate Pydantic models at runtime based on whatever
rules we wished. But this is unsatisfying, because we would not be
able to properly statically typecheck the functions.</p>
<p>(Example code for implementing this <a class="reference internal" href="#pep827-fastapi-impl"><span class="std std-ref">below</span></a>.)</p>
</section>
<section id="dataclasses-style-method-generation">
<h3><a class="toc-backref" href="#dataclasses-style-method-generation" role="doc-backlink">dataclasses-style method generation</a></h3>
<p>We would additionally like to be able to generate method signatures
based on the attributes of an object. The most well-known example of
this is generating <code class="docutils literal notranslate"><span class="pre">__init__</span></code> methods for dataclasses,
which we present a simplified example of.</p>
<p>This kind of pattern is widespread enough that <a class="pep reference internal" href="../pep-0681/" title="PEP 681 – Data Class Transforms">PEP 681</a>
was created to represent a lowest-common denominator subset of what
existing libraries do.</p>
<p>Making it possible for libraries to implement more of these patterns
directly in the type system will give better typing without needing
further special casing, typechecker plugins, hardcoded support, etc.</p>
<p>(Example code for implementing this <a class="reference internal" href="#pep827-init-impl"><span class="std std-ref">below</span></a>.)</p>
</section>
<section id="more-powerful-decorator-typing">
<h3><a class="toc-backref" href="#more-powerful-decorator-typing" role="doc-backlink">More powerful decorator typing</a></h3>
<p>The typing of decorator functions has long been a pain point in Python
typing. The situation was substantially improved by the introduction of
<code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code> in <a class="pep reference internal" href="../pep-0612/" title="PEP 612 – Parameter Specification Variables">PEP 612</a>, but a number of patterns remain
unsupported:</p>
<ul class="simple">
<li>Adding/removing/modifying a keyword parameter.</li>
<li>Adding/removing/modifying a variable number of parameters. (Though
<code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> is close to being able to support adding and
removing, if multiple unpackings were to be allowed, and Pyre
implemented a <code class="docutils literal notranslate"><span class="pre">Map</span></code> operator that allowed modifying multiple.)</li>
</ul>
<p>This proposal will cover those cases.</p>
</section>
</section>
<section id="specification-of-some-prerequisites">
<h2><a class="toc-backref" href="#specification-of-some-prerequisites" role="doc-backlink">Specification of Some Prerequisites</a></h2>
<p>We have two subproposals that are necessary to get mileage out of the
main part of this proposal.</p>
<section id="unpack-of-typevars-for-kwargs">
<span id="pep827-unpack-kwargs"></span><h3><a class="toc-backref" href="#unpack-of-typevars-for-kwargs" role="doc-backlink">Unpack of typevars for <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code></a></h3>
<p>A minor proposal that can probably be split off into a typing proposal
without a PEP:</p>
<p>Supporting <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> of typevars for <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">[</span><span class="n">K</span><span class="p">:</span> <span class="n">BaseTypedDict</span><span class="p">](</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">K</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">K</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">kwargs</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">BaseTypedDict</span></code> is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">BaseTypedDict</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>But any <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.TypedDict" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></a> would be allowed there.</p>
<p>Then, if we had a call like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span>
<span class="n">y</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>the type inferred for <code class="docutils literal notranslate"><span class="pre">K</span></code> would be something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TypedDict</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]})</span>
</pre></div>
</div>
<p>This is basically a combination of
<a class="pep reference internal" href="../pep-0692/" title="PEP 692 – Using TypedDict for more precise **kwargs typing">PEP 692</a> “Using TypedDict for more precise <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> typing”
and the behavior of <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> for <code class="docutils literal notranslate"><span class="pre">*args</span></code>
from <a class="pep reference internal" href="../pep-0646/" title="PEP 646 – Variadic Generics">PEP 646</a> “Variadic Generics”.</p>
<p>When inferring types here, the type checker should <strong>infer literal
types when possible</strong>.  This means inferring literal types for
arguments that <strong>do not</strong> appear in the bound, as well as
for arguments that <strong>do</strong> appear in the bound as read-only.</p>
<p>For each non-required item in the bound that does <strong>not</strong> have a
matching argument provided, then if the item is read-only, it will
have its type inferred as <code class="docutils literal notranslate"><span class="pre">Never</span></code>, to indicate that it was not
provided.  (This can only be done for read-only items, since non
read-only items are invariant.)</p>
<p>This is potentially moderately useful on its own but is being done to
support processing <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> with type level computation.</p>
</section>
<section id="extended-callables">
<span id="pep827-extended-callables-prereq"></span><h3><a class="toc-backref" href="#extended-callables" role="doc-backlink">Extended Callables</a></h3>
<p>We introduce a new extended callable proposal for expressing
arbitrarily complex callable types. The goal here is <strong>not</strong> to have a
new syntax to write in annotations (it’s quite verbose for that), but
to provide a way of constructing the types that is amenable to
creating and introspecting callable types using the other features of
this PEP.</p>
<p>We introduce a <code class="docutils literal notranslate"><span class="pre">Param</span></code> type that contains all the information about a function param:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Param</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="n">ParamQuals</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Never</span><span class="p">]:</span>
    <span class="k">pass</span>

<span class="n">ParamQuals</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;**&quot;</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="s2">&quot;keyword&quot;</span><span class="p">]</span>

<span class="nb">type</span> <span class="n">PosParam</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Param</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;positional&quot;</span><span class="p">]]</span>
<span class="nb">type</span> <span class="n">PosDefaultParam</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Param</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;positional&quot;</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">]]</span>
<span class="nb">type</span> <span class="n">DefaultParam</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Param</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">]]</span>
<span class="nb">type</span> <span class="n">NamedParam</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Param</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;keyword&quot;</span><span class="p">]]</span>
<span class="nb">type</span> <span class="n">NamedDefaultParam</span><span class="p">[</span><span class="n">N</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Param</span><span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;keyword&quot;</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">]]</span>
<span class="nb">type</span> <span class="n">ArgsParam</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">]]</span>
<span class="nb">type</span> <span class="n">KwargsParam</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;**&quot;</span><span class="p">]]</span>
</pre></div>
</div>
<p>And then, we can represent the type of a function like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">e</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Callable</span><span class="p">[</span>
    <span class="p">[</span>
        <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;positional&quot;</span><span class="p">]],</span>
        <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">]],</span>
        <span class="n">Param</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">]],</span>
        <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;keyword&quot;</span><span class="p">]],</span>
        <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="s2">&quot;keyword&quot;</span><span class="p">]],</span>
        <span class="n">Param</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;**&quot;</span><span class="p">]],</span>
    <span class="p">],</span>
    <span class="nb">int</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>
</div>
<p>or, using the type abbreviations we provide:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Callable</span><span class="p">[</span>
    <span class="p">[</span>
        <span class="n">PosParam</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">DefaultParam</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">ArgsParam</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">NamedParam</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;d&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">NamedDefaultParam</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">KwargsParam</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">],</span>
    <span class="nb">int</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>
</div>
<p>(Rationale discussed <a class="reference internal" href="#pep827-callable-rationale"><span class="std std-ref">below</span></a>.)</p>
</section>
</section>
<section id="specification">
<h2><a class="toc-backref" href="#specification" role="doc-backlink">Specification</a></h2>
<p>As was visible in the examples above, we introduce a few new syntactic
forms of valid types, but much of the power comes from type level
<strong>operators</strong> that will be defined in the <code class="docutils literal notranslate"><span class="pre">typing</span></code> module.</p>
<section id="grammar-specification-of-the-extensions-to-the-type-language">
<h3><a class="toc-backref" href="#grammar-specification-of-the-extensions-to-the-type-language" role="doc-backlink">Grammar specification of the extensions to the type language</a></h3>
<p>No changes to the <strong>Python</strong> grammar are being proposed, only
to the grammar of what Python expressions are considered as valid types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">...</span>
     <span class="c1"># Type booleans are all valid types too</span>
     <span class="o">|</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span>

     <span class="c1"># Conditional types</span>
     <span class="o">|</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="k">if</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="k">else</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span>

     <span class="c1"># Types with variadic arguments can have</span>
     <span class="c1"># *[... for t in ...] arguments</span>
     <span class="o">|</span> <span class="o">&lt;</span><span class="n">ident</span><span class="o">&gt;</span><span class="p">[</span><span class="o">&lt;</span><span class="n">variadic</span><span class="o">-</span><span class="nb">type</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span> <span class="o">+</span><span class="p">]</span>

     <span class="c1"># Type member access</span>
     <span class="o">|</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;.&lt;</span><span class="n">name</span><span class="o">&gt;</span>

     <span class="o">|</span> <span class="n">GenericCallable</span><span class="p">[</span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">&lt;</span><span class="n">args</span><span class="o">&gt;</span><span class="p">:</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span><span class="p">]</span>

<span class="c1"># Type conditional checks are boolean compositions of</span>
<span class="c1"># boolean type operators</span>
<span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="o">=</span>
      <span class="o">&lt;</span><span class="nb">bool</span><span class="o">-</span><span class="n">operator</span><span class="o">&gt;</span><span class="p">[</span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">+</span><span class="p">]</span>
    <span class="o">|</span> <span class="ow">not</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span>
    <span class="o">|</span> <span class="nb">any</span><span class="p">(</span><span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">-</span><span class="k">for</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="o">|</span> <span class="nb">all</span><span class="p">(</span><span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">-</span><span class="k">for</span><span class="o">&gt;</span><span class="p">)</span>

<span class="o">&lt;</span><span class="n">variadic</span><span class="o">-</span><span class="nb">type</span><span class="o">-</span><span class="n">arg</span><span class="o">&gt;</span> <span class="o">=</span>
      <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="p">,</span>
    <span class="o">|</span> <span class="o">*</span> <span class="p">[</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="k">for</span><span class="o">-</span><span class="nb">iter</span><span class="o">&gt;</span> <span class="p">]</span> <span class="p">,</span>


<span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="k">for</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="k">for</span><span class="o">-</span><span class="nb">iter</span><span class="o">&gt;+</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="k">for</span><span class="o">-</span><span class="k">if</span><span class="o">&gt;*</span>
<span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="k">for</span><span class="o">-</span><span class="nb">iter</span><span class="o">&gt;</span> <span class="o">=</span>
      <span class="c1"># Iterate over a tuple type</span>
      <span class="k">for</span> <span class="o">&lt;</span><span class="n">var</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="n">Iter</span><span class="p">[</span><span class="o">&lt;</span><span class="nb">type</span><span class="o">&gt;</span><span class="p">]</span>
<span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="k">for</span><span class="o">-</span><span class="k">if</span><span class="o">&gt;</span> <span class="o">=</span>
      <span class="k">if</span> <span class="o">&lt;</span><span class="nb">type</span><span class="o">-</span><span class="nb">bool</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Where:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">&lt;bool-operator&gt;</span></code> refers to any of the names defined in the
<a class="reference internal" href="#pep827-boolean-ops"><span class="std std-ref">Boolean Operators</span></a> section, whether used directly,
qualified, or under another name.</li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;type-bool-for&gt;</span></code> is identical to <code class="docutils literal notranslate"><span class="pre">&lt;type-for&gt;</span></code> except that the
result type is a <code class="docutils literal notranslate"><span class="pre">&lt;type-bool&gt;</span></code> instead of a <code class="docutils literal notranslate"><span class="pre">&lt;type&gt;</span></code>.</li>
</ul>
<p>There are three and a half core syntactic features introduced: type booleans,
conditional types, unpacked comprehension types, and type member access.</p>
<p><a class="reference internal" href="#pep827-generic-callable"><span class="std std-ref">“Generic callables”</span></a> are also technically a
syntactic feature, but are discussed as an operator.</p>
<section id="type-booleans">
<h4><a class="toc-backref" href="#type-booleans" role="doc-backlink">Type booleans</a></h4>
<p>Type booleans are a special subset of the type language that can be
used in the body of conditionals.  They consist of the <a class="reference internal" href="#pep827-boolean-ops"><span class="std std-ref">Boolean
Operators</span></a>, defined below, potentially combined with
<code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">not</span></code>, <code class="docutils literal notranslate"><span class="pre">all</span></code>, and <code class="docutils literal notranslate"><span class="pre">any</span></code>. For <code class="docutils literal notranslate"><span class="pre">all</span></code> and
<code class="docutils literal notranslate"><span class="pre">any</span></code>, the argument is a comprehension of type booleans, evaluated
in the same way as the <a class="reference internal" href="#pep827-unpacked"><span class="std std-ref">unpacked comprehensions</span></a>.</p>
<p>When evaluated in type annotation context, they will evaluate to
<code class="docutils literal notranslate"><span class="pre">Literal[True]</span></code> or <code class="docutils literal notranslate"><span class="pre">Literal[False]</span></code>.</p>
<p>We restrict what operators may be used in a conditional
so that at runtime, we can have those operators produce “type” values
with appropriate behavior, without needing to change the behavior of
existing <code class="docutils literal notranslate"><span class="pre">Literal[False]</span></code> values and the like.</p>
</section>
<section id="conditional-types">
<h4><a class="toc-backref" href="#conditional-types" role="doc-backlink">Conditional types</a></h4>
<p>The type <code class="docutils literal notranslate"><span class="pre">true_typ</span> <span class="pre">if</span> <span class="pre">bool_typ</span> <span class="pre">else</span> <span class="pre">false_typ</span></code> is a conditional
type, which resolves to <code class="docutils literal notranslate"><span class="pre">true_typ</span></code> if <code class="docutils literal notranslate"><span class="pre">bool_typ</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">Literal[True]</span></code> and to <code class="docutils literal notranslate"><span class="pre">false_typ</span></code> otherwise.</p>
<p><code class="docutils literal notranslate"><span class="pre">bool_typ</span></code> is a type, but it needs to syntactically be a type boolean,
defined above.</p>
</section>
<section id="unpacked-comprehension">
<span id="pep827-unpacked"></span><h4><a class="toc-backref" href="#unpacked-comprehension" role="doc-backlink">Unpacked comprehension</a></h4>
<p>An unpacked comprehension, <code class="docutils literal notranslate"><span class="pre">*[ty</span> <span class="pre">for</span> <span class="pre">t</span> <span class="pre">in</span> <span class="pre">Iter[iter_ty]]</span></code> may appear
anywhere in a type that <code class="docutils literal notranslate"><span class="pre">Unpack[...]</span></code> is currently allowed, and it
evaluates essentially to an <code class="docutils literal notranslate"><span class="pre">Unpack</span></code> of a tuple produced by a list
comprehension iterating over the arguments of tuple type <code class="docutils literal notranslate"><span class="pre">iter_ty</span></code>.</p>
<p>The comprehension may also have <code class="docutils literal notranslate"><span class="pre">if</span></code> clauses, which filter in the
usual way.</p>
</section>
<section id="type-member-access">
<h4><a class="toc-backref" href="#type-member-access" role="doc-backlink">Type member access</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Member</span></code> and <code class="docutils literal notranslate"><span class="pre">Param</span></code> types introduced to represent class
members and function params have “associated” type members, which can
be accessed by dot notation: <code class="docutils literal notranslate"><span class="pre">m.name</span></code>, <code class="docutils literal notranslate"><span class="pre">m.type</span></code>, etc.</p>
<p>This operation is not lifted over union types. Using it on the wrong
sort of type will be an error. It must be that way at runtime,
and we want typechecking to match.</p>
</section>
</section>
<section id="type-operators">
<h3><a class="toc-backref" href="#type-operators" role="doc-backlink">Type operators</a></h3>
<p>Many of the operators specified have type bounds listed for some of
their operands. These should be interpreted more as documentation than
as exact type bounds. Trying to evaluate operators with invalid
arguments will produce <code class="docutils literal notranslate"><span class="pre">Never</span></code> as the return. (There is some
discussion of potential alternatives <a class="reference internal" href="#pep827-strict-kinds"><span class="std std-ref">below</span></a>.)</p>
<p>Note that in some of these bounds below we write things like
<code class="docutils literal notranslate"><span class="pre">Literal[int]</span></code> to mean “a literal that is of type <code class="docutils literal notranslate"><span class="pre">int</span></code>”.
We don’t propose to add that as actual syntax yet.</p>
<section id="boolean-operators">
<span id="pep827-boolean-ops"></span><h4><a class="toc-backref" href="#boolean-operators" role="doc-backlink">Boolean operators</a></h4>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">IsAssignable[T,</span> <span class="pre">S]</span></code>: Returns a boolean literal type indicating whether
<code class="docutils literal notranslate"><span class="pre">T</span></code> is assignable to <code class="docutils literal notranslate"><span class="pre">S</span></code>.<p>That is, it is a “consistent subtype”. This is subtyping extended
to gradual types.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">IsEquivalent[T,</span> <span class="pre">S]</span></code>:
Equivalent to <code class="docutils literal notranslate"><span class="pre">IsAssignable[T,</span> <span class="pre">S]</span> <span class="pre">and</span> <span class="pre">IsAssignable[S,</span> <span class="pre">T]</span></code>.
Technically this relation is “consistency” in the typing spec, not
equivalence.</li>
<li><code class="docutils literal notranslate"><span class="pre">Bool[T]</span></code>: Returns <code class="docutils literal notranslate"><span class="pre">Literal[True]</span></code> if <code class="docutils literal notranslate"><span class="pre">T</span></code> is also
<code class="docutils literal notranslate"><span class="pre">Literal[True]</span></code> or a union containing it.
Equivalent to <code class="docutils literal notranslate"><span class="pre">IsAssignable[T,</span> <span class="pre">Literal[True]]</span> <span class="pre">and</span> <span class="pre">not</span> <span class="pre">IsAssignable[T,</span> <span class="pre">Never]</span></code>.<p>This is useful for invoking “helper aliases” that return a boolean
literal type.</p>
</li>
</ul>
</section>
<section id="basic-operators">
<h4><a class="toc-backref" href="#basic-operators" role="doc-backlink">Basic operators</a></h4>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">GetArg[T,</span> <span class="pre">Base,</span> <span class="pre">Idx:</span> <span class="pre">Literal[int]]</span></code>: returns the type argument
number <code class="docutils literal notranslate"><span class="pre">Idx</span></code> to <code class="docutils literal notranslate"><span class="pre">T</span></code> when interpreted as <code class="docutils literal notranslate"><span class="pre">Base</span></code>, or <code class="docutils literal notranslate"><span class="pre">Never</span></code>
if it cannot be. (That is, if we have <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">A(B[C]):</span> <span class="pre">...</span></code>, then
<code class="docutils literal notranslate"><span class="pre">GetArg[A,</span> <span class="pre">B,</span> <span class="pre">Literal[0]]</span> <span class="pre">==</span> <span class="pre">C</span></code>
while <code class="docutils literal notranslate"><span class="pre">GetArg[A,</span> <span class="pre">A,</span> <span class="pre">Literal[0]]</span> <span class="pre">==</span> <span class="pre">Never</span></code>).<p>Negative indexes work in the usual way.</p>
<p>Note that runtime evaluation will only be able to support proper classes
as <code class="docutils literal notranslate"><span class="pre">Base</span></code>, <em>not</em> protocols. So, for example, <code class="docutils literal notranslate"><span class="pre">GetArg[Ty,</span>
<span class="pre">Iterable,</span> <span class="pre">Literal[0]]</span></code> to get the type of something iterable will
fail in the runtime evaluator.</p>
<p>Special forms require special handling: the arguments list of a <code class="docutils literal notranslate"><span class="pre">Callable</span></code>
will be packed in a tuple, and a <code class="docutils literal notranslate"><span class="pre">...</span></code> will become
<code class="docutils literal notranslate"><span class="pre">SpecialFormEllipsis</span></code>.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">GetArgs[T,</span> <span class="pre">Base]</span></code>: returns a tuple containing all of the type
arguments of <code class="docutils literal notranslate"><span class="pre">T</span></code> when interpreted as <code class="docutils literal notranslate"><span class="pre">Base</span></code>, or <code class="docutils literal notranslate"><span class="pre">Never</span></code> if it
cannot be.</li>
<li><code class="docutils literal notranslate"><span class="pre">GetMemberType[T,</span> <span class="pre">S:</span> <span class="pre">Literal[str]]</span></code>: Extract the type of the
member named <code class="docutils literal notranslate"><span class="pre">S</span></code> from the class <code class="docutils literal notranslate"><span class="pre">T</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">Length[T:</span> <span class="pre">tuple]</span></code> - Gets the length of a tuple as an int literal
(or <code class="docutils literal notranslate"><span class="pre">Literal[None]</span></code> if it is unbounded)</li>
<li><code class="docutils literal notranslate"><span class="pre">Slice[S:</span> <span class="pre">tuple,</span> <span class="pre">Start:</span> <span class="pre">Literal[int</span> <span class="pre">|</span> <span class="pre">None],</span> <span class="pre">End:</span> <span class="pre">Literal[int</span> <span class="pre">|</span> <span class="pre">None]]</span></code>:
Slices a tuple type.</li>
<li><code class="docutils literal notranslate"><span class="pre">GetSpecialAttr[T,</span> <span class="pre">Attr:</span> <span class="pre">Literal[str]]</span></code>: Extracts the value
of the special attribute named <code class="docutils literal notranslate"><span class="pre">Attr</span></code> from the class <code class="docutils literal notranslate"><span class="pre">T</span></code>. Valid
attributes are <code class="docutils literal notranslate"><span class="pre">__name__</span></code>, <code class="docutils literal notranslate"><span class="pre">__module__</span></code>, and <code class="docutils literal notranslate"><span class="pre">__qualname__</span></code>.
Returns the value as a <code class="docutils literal notranslate"><span class="pre">Literal[str]</span></code>.</li>
</ul>
<p>All of the operators in this section are <a class="reference internal" href="#pep827-lifting"><span class="std std-ref">lifted over union types</span></a>.</p>
</section>
<section id="union-processing">
<h4><a class="toc-backref" href="#union-processing" role="doc-backlink">Union processing</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">FromUnion[T]</span></code>: Returns a tuple containing all of the union
elements, or a 1-ary tuple containing T if it is not a union.</li>
<li><code class="docutils literal notranslate"><span class="pre">Union[*Ts]</span></code>: <code class="docutils literal notranslate"><span class="pre">Union</span></code> will become able to take variadic
arguments, so that it can take unpacked comprehension arguments.</li>
</ul>
</section>
<section id="object-inspection">
<h4><a class="toc-backref" href="#object-inspection" role="doc-backlink">Object inspection</a></h4>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">Members[T]</span></code>: produces a <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">Member</span></code> types describing
the members (attributes and methods) of class or typed dict <code class="docutils literal notranslate"><span class="pre">T</span></code>.<p>In order to allow typechecking time and runtime evaluation to coincide
more closely, <strong>only members with explicit type annotations are included</strong>.</p>
</li>
<li><code class="docutils literal notranslate"><span class="pre">Attrs[T]</span></code>: like <code class="docutils literal notranslate"><span class="pre">Members[T]</span></code> but only returns attributes (not
methods).</li>
<li><code class="docutils literal notranslate"><span class="pre">GetMember[T,</span> <span class="pre">S:</span> <span class="pre">Literal[str]]</span></code>: Produces a <code class="docutils literal notranslate"><span class="pre">Member</span></code> type for the
member named <code class="docutils literal notranslate"><span class="pre">S</span></code> from the class <code class="docutils literal notranslate"><span class="pre">T</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">Member[N:</span> <span class="pre">Literal[str],</span> <span class="pre">T,</span> <span class="pre">Q:</span> <span class="pre">MemberQuals,</span> <span class="pre">Init,</span> <span class="pre">D]</span></code>: <code class="docutils literal notranslate"><span class="pre">Member</span></code>,
is a simple type, not an operator, that is used to describe members
of classes.  Its type parameters encode the information about each
member.<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">N</span></code> is the name, as a literal string type. Accessible with <code class="docutils literal notranslate"><span class="pre">.name</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code> is the type. Accessible with <code class="docutils literal notranslate"><span class="pre">.type</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">Q</span></code> is a union of qualifiers (see <code class="docutils literal notranslate"><span class="pre">MemberQuals</span></code> below). Accessible with <code class="docutils literal notranslate"><span class="pre">.quals</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">Init</span></code> is the literal type of the attribute initializer in the
class (see <a class="reference internal" href="#pep827-init-field"><span class="std std-ref">InitField</span></a>). Accessible with <code class="docutils literal notranslate"><span class="pre">.init</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">D</span></code> is the defining class of the member. (That is, which class
the member is inherited from. Always <code class="docutils literal notranslate"><span class="pre">Never</span></code>, for a <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code>).
Accessible with <code class="docutils literal notranslate"><span class="pre">.definer</span></code>.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">MemberQuals</span> <span class="pre">=</span> <span class="pre">Literal['ClassVar',</span> <span class="pre">'Final',</span> <span class="pre">'NotRequired',</span> <span class="pre">'ReadOnly']</span></code> -
<code class="docutils literal notranslate"><span class="pre">MemberQuals</span></code> is the type of “qualifiers” that can apply to a
member; currently <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> and <code class="docutils literal notranslate"><span class="pre">Final</span></code> apply to classes, and
<code class="docutils literal notranslate"><span class="pre">NotRequired</span></code> and <code class="docutils literal notranslate"><span class="pre">ReadOnly</span></code> apply to typed dicts.</li>
</ul>
<p>Methods are returned as callables using the new <code class="docutils literal notranslate"><span class="pre">Param</span></code> based
extended callables, and carrying the <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code>
qualifier. <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> and <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> will return
<code class="docutils literal notranslate"><span class="pre">staticmethod</span></code> and <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> types, which are subscriptable as
of Python 3.14.</p>
<p>All of the operators in this section are <a class="reference internal" href="#pep827-lifting"><span class="std std-ref">lifted over union types</span></a>.</p>
</section>
<section id="object-creation">
<h4><a class="toc-backref" href="#object-creation" role="doc-backlink">Object creation</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">NewProtocol[*Ms:</span> <span class="pre">Member]</span></code>: Create a new structural protocol with members
specified by <code class="docutils literal notranslate"><span class="pre">Member</span></code> arguments</li>
<li><code class="docutils literal notranslate"><span class="pre">NewTypedDict[*Ps:</span> <span class="pre">Member]</span></code> - Creates a new <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> with
items specified by the <code class="docutils literal notranslate"><span class="pre">Member</span></code> arguments.</li>
</ul>
<p>Note that we are not currently proposing any way to create <em>nominal</em> classes
or any way to make new <em>generic</em> types.</p>
</section>
<section id="initfield">
<span id="pep827-init-field"></span><h4><a class="toc-backref" href="#initfield" role="doc-backlink">InitField</a></h4>
<p>We want to be able to support transforming types based on
dataclasses/attrs/Pydantic-style field descriptors.  In order to do
that, we need to be able to consume operations like calls to <code class="docutils literal notranslate"><span class="pre">Field</span></code>.</p>
<p>Our strategy for this is to introduce a new type
<code class="docutils literal notranslate"><span class="pre">InitField[KwargDict]</span></code> that collects arguments defined by a
<code class="docutils literal notranslate"><span class="pre">KwargDict:</span> <span class="pre">TypedDict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">InitField</span><span class="p">[</span><span class="n">KwargDict</span><span class="p">:</span> <span class="n">BaseTypedDict</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Unpack</span><span class="p">[</span><span class="n">KwargDict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">KwargDict</span><span class="p">:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">InitField</span></code> or (more likely) a subtype of it is instantiated
inside a class body, we infer a <em>more specific</em> type for it, based on
<code class="docutils literal notranslate"><span class="pre">Literal</span></code> types where possible. (Though actually, this is just an
application of the rule that typevar unpacking in <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> should
use <code class="docutils literal notranslate"><span class="pre">Literal</span></code> types.)</p>
<p>So if we write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">:</span>
    <span class="n">foo</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">InitField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>then we would infer the type <code class="docutils literal notranslate"><span class="pre">InitField[TypedDict('...',</span> <span class="pre">{'default':</span>
<span class="pre">Literal[0],</span> <span class="pre">'kw_only':</span> <span class="pre">Literal[True]})]</span></code> for the initializer, and
that would be made available as the <code class="docutils literal notranslate"><span class="pre">Init</span></code> field of the <code class="docutils literal notranslate"><span class="pre">Member</span></code>.</p>
</section>
<section id="callable-inspection-and-creation">
<h4><a class="toc-backref" href="#callable-inspection-and-creation" role="doc-backlink">Callable inspection and creation</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Callable</span></code> types always have their arguments exposed in the extended
Callable format discussed above.</p>
<p>The names, type, and qualifiers share associated type names with
<code class="docutils literal notranslate"><span class="pre">Member</span></code> (<code class="docutils literal notranslate"><span class="pre">.name</span></code>, <code class="docutils literal notranslate"><span class="pre">.type</span></code>, and <code class="docutils literal notranslate"><span class="pre">.quals</span></code>).</p>
</section>
<section id="generic-callable">
<span id="pep827-generic-callable"></span><h4><a class="toc-backref" href="#generic-callable" role="doc-backlink">Generic Callable</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">GenericCallable[Vs,</span> <span class="pre">lambda</span> <span class="pre">&lt;vs&gt;:</span> <span class="pre">Ty]</span></code>: A generic callable. <code class="docutils literal notranslate"><span class="pre">Vs</span></code>
are a tuple type of unbound type variables and <code class="docutils literal notranslate"><span class="pre">Ty</span></code> should be a
<code class="docutils literal notranslate"><span class="pre">Callable</span></code>, <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code>, or <code class="docutils literal notranslate"><span class="pre">classmethod</span></code> that has access
to the variables in <code class="docutils literal notranslate"><span class="pre">Vs</span></code> via the bound variables in <code class="docutils literal notranslate"><span class="pre">&lt;vs&gt;</span></code>.</li>
</ul>
<p>For now, we restrict the use of <code class="docutils literal notranslate"><span class="pre">GenericCallable</span></code> to
the type argument of <code class="docutils literal notranslate"><span class="pre">Member</span></code>, to disallow its use for
locals, parameter types, return types, nested inside other types,
etc.  Rationale discussed <a class="reference internal" href="#pep827-generic-callable-rationale"><span class="std std-ref">below</span></a>.</p>
</section>
<section id="overloaded-function-types">
<h4><a class="toc-backref" href="#overloaded-function-types" role="doc-backlink">Overloaded function types</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Overloaded[*Callables]</span></code> - An overloaded function type, with the
underlying types in order.</li>
</ul>
</section>
<section id="raise-error">
<h4><a class="toc-backref" href="#raise-error" role="doc-backlink">Raise error</a></h4>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">RaiseError[S:</span> <span class="pre">Literal[str],</span> <span class="pre">*Ts]</span></code>: If this type needs to be evaluated
to determine some actual type, generate a type error with the
provided message.<p>Any additional type arguments should be included in the message.</p>
</li>
</ul>
</section>
<section id="update-class">
<span id="pep827-update-class"></span><h4><a class="toc-backref" href="#update-class" role="doc-backlink">Update class</a></h4>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">UpdateClass[*Ps:</span> <span class="pre">Member]</span></code>: A special form that <em>updates</em> an
existing nominal class with new members (possibly overriding old
ones, or removing them by making them have type <code class="docutils literal notranslate"><span class="pre">Never</span></code>).<p>This can only be used in the return type of a type decorator
or as the return type of <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>.</p>
<p>When a class is declared, if one or more of its ancestors have an
<code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> with an <code class="docutils literal notranslate"><span class="pre">UpdateClass</span></code> return type, they are
applied in reverse MRO order. N.B: If the <code class="docutils literal notranslate"><span class="pre">cls</span></code> param is
parameterized by <code class="docutils literal notranslate"><span class="pre">type[T]</span></code>, then the class type should be
substituted in for <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
</li>
</ul>
</section>
</section>
<section id="lifting-over-unions">
<span id="pep827-lifting"></span><h3><a class="toc-backref" href="#lifting-over-unions" role="doc-backlink">Lifting over Unions</a></h3>
<p>Many of the builtin operations are “lifted” over <code class="docutils literal notranslate"><span class="pre">Union</span></code>.</p>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Concat</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;ac&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;ad&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;bc&#39;</span><span class="p">]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;bd&#39;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>When an operation is lifted over union types, we take the cross
product of the union elements for each argument position, evaluate the
operator for each tuple in the cross product, and then union all of
the results together. In Python, the logic looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">args_union_els</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_union_elems</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">eval_operator</span><span class="p">(</span><span class="o">*</span><span class="n">xs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">args_union_els</span><span class="p">)</span>
<span class="p">]</span>
<span class="k">if</span> <span class="n">results</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="o">*</span><span class="n">results</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Never</span>
</pre></div>
</div>
</section>
<section id="runtime-evaluation-support">
<span id="pep827-rt-support"></span><h3><a class="toc-backref" href="#runtime-evaluation-support" role="doc-backlink">Runtime evaluation support</a></h3>
<p>An important goal is supporting runtime evaluation of these computed
types.  We <strong>do not</strong> propose to add an official evaluator to the standard
library, but intend to release a third-party evaluator library.</p>
<p>While most of the extensions to the type system are “inert” type
operator applications, the syntax also includes list iteration,
conditionals, and attribute access, which will be automatically
evaluated when the <code class="docutils literal notranslate"><span class="pre">__annotate__</span></code> method of a class, alias, or
function is called.</p>
<p>In order to allow an evaluator library to trigger type evaluation in
those cases, we add a new hook to <code class="docutils literal notranslate"><span class="pre">typing</span></code>:</p>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">special_form_evaluator</span></code>: This is a <code class="docutils literal notranslate"><span class="pre">ContextVar</span></code> that holds a
callable that will be invoked with a <code class="docutils literal notranslate"><span class="pre">typing._GenericAlias</span></code>
argument when <code class="docutils literal notranslate"><span class="pre">__bool__</span></code> is called on a
<a class="reference internal" href="#pep827-boolean-ops"><span class="std std-ref">Boolean Operator</span></a> or <code class="docutils literal notranslate"><span class="pre">__iter__</span></code> is called
on <code class="docutils literal notranslate"><span class="pre">typing.Iter</span></code>.
The returned value will then have <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">iter</span></code> called upon
it before being returned.<p>If set to <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), the boolean operators will return
<code class="docutils literal notranslate"><span class="pre">False</span></code> while <code class="docutils literal notranslate"><span class="pre">Iter</span></code> will evaluate to <code class="docutils literal notranslate"><span class="pre">iter(())</span></code>.</p>
</li>
</ul>
<p>There has been some discussion of adding a <code class="docutils literal notranslate"><span class="pre">Format.AST</span></code> mode for
fetching annotations (see this <a class="reference external" href="https://imogenbits-peps.readthedocs.io/en/ast_format/pep-9999/">PEP draft</a>). That
would combine extremely well with this proposal, as it would make it
easy to still fetch fully unevaluated annotations.</p>
</section>
</section>
<section id="examples-tutorial">
<h2><a class="toc-backref" href="#examples-tutorial" role="doc-backlink">Examples / Tutorial</a></h2>
<p>Here we will take something of a tutorial approach in discussing how
to achieve the goals in the examples in the motivation section,
explain the features being used as we use them.</p>
<section id="pep827-qb-impl">
<span id="id1"></span><h3><a class="toc-backref" href="#pep827-qb-impl" role="doc-backlink">Prisma-style ORMs</a></h3>
<p>First, to support the annotations we saw above, we have a collection
of dummy classes with generic types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Pointer</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Property</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Pointer</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Link</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Pointer</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SingleLink</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Link</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MultiLink</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">Link</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">select</span></code> method is where we start seeing new things.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">**kwargs:</span> <span class="pre">Unpack[K]</span></code> is part of this proposal, and allows
<em>inferring</em> a TypedDict from keyword args.</p>
<p><code class="docutils literal notranslate"><span class="pre">Attrs[K]</span></code> extracts <code class="docutils literal notranslate"><span class="pre">Member</span></code> types corresponding to every
type-annotated attribute of <code class="docutils literal notranslate"><span class="pre">K</span></code>, while calling <code class="docutils literal notranslate"><span class="pre">NewProtocol</span></code> with
<code class="docutils literal notranslate"><span class="pre">Member</span></code> arguments constructs a new structural type.</p>
<p><code class="docutils literal notranslate"><span class="pre">c.name</span></code> fetches the name of the <code class="docutils literal notranslate"><span class="pre">Member</span></code> bound to the variable <code class="docutils literal notranslate"><span class="pre">c</span></code>
as a literal type–all of these mechanisms lean very heavily on literal types.
<code class="docutils literal notranslate"><span class="pre">GetMemberType</span></code> gets the type of an attribute from a class.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">select</span><span class="p">[</span><span class="n">ModelT</span><span class="p">,</span> <span class="n">K</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">BaseTypedDict</span><span class="p">](</span>
    <span class="n">typ</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">ModelT</span><span class="p">],</span>
    <span class="o">/</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">K</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span>
    <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">[</span>
        <span class="o">*</span><span class="p">[</span>
            <span class="n">typing</span><span class="o">.</span><span class="n">Member</span><span class="p">[</span>
                <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">ConvertField</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">GetMemberType</span><span class="p">[</span><span class="n">ModelT</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">]],</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">[</span><span class="n">K</span><span class="p">]]</span>
        <span class="p">]</span>
    <span class="p">]</span>
<span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ConvertField</span></code> is our first type helper, and it is a conditional type
alias, which decides between two types based on a (limited)
subtype-ish check.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">ConvertField</span></code>, we wish to drop the <code class="docutils literal notranslate"><span class="pre">Property</span></code> or <code class="docutils literal notranslate"><span class="pre">Link</span></code>
annotation and produce the underlying type, as well as, for links,
producing a new target type containing only properties and wrapping
<code class="docutils literal notranslate"><span class="pre">MultiLink</span></code> in a list.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">ConvertField</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">AdjustLink</span><span class="p">[</span><span class="n">PropsOnly</span><span class="p">[</span><span class="n">PointerArg</span><span class="p">[</span><span class="n">T</span><span class="p">]],</span> <span class="n">T</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Link</span><span class="p">]</span>
    <span class="k">else</span> <span class="n">PointerArg</span><span class="p">[</span><span class="n">T</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">PointerArg</span></code> gets the type argument to <code class="docutils literal notranslate"><span class="pre">Pointer</span></code> or a subclass.</p>
<p><code class="docutils literal notranslate"><span class="pre">GetArg[T,</span> <span class="pre">Base,</span> <span class="pre">I]</span></code> is one of the core primitives; it fetches the
index <code class="docutils literal notranslate"><span class="pre">I</span></code> type argument to <code class="docutils literal notranslate"><span class="pre">Base</span></code> from a type <code class="docutils literal notranslate"><span class="pre">T</span></code>, if <code class="docutils literal notranslate"><span class="pre">T</span></code>
inherits from <code class="docutils literal notranslate"><span class="pre">Base</span></code>.</p>
<p>(The subtleties of this will be discussed later; in this case, it just
grabs the argument to a <code class="docutils literal notranslate"><span class="pre">Pointer</span></code>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">PointerArg</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">GetArg</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Pointer</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AdjustLink</span></code> sticks a <code class="docutils literal notranslate"><span class="pre">list</span></code> around <code class="docutils literal notranslate"><span class="pre">MultiLink</span></code>, using features
we’ve discussed already.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">AdjustLink</span><span class="p">[</span><span class="n">Tgt</span><span class="p">,</span> <span class="n">LinkTy</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="nb">list</span><span class="p">[</span><span class="n">Tgt</span><span class="p">]</span> <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">LinkTy</span><span class="p">,</span> <span class="n">MultiLink</span><span class="p">]</span> <span class="k">else</span> <span class="n">Tgt</span>
<span class="p">)</span>
</pre></div>
</div>
<p>And the final helper, <code class="docutils literal notranslate"><span class="pre">PropsOnly[T]</span></code>, generates a new type that
contains all the <code class="docutils literal notranslate"><span class="pre">Property</span></code> attributes of <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">PropsOnly</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">[</span>
    <span class="o">*</span><span class="p">[</span>
        <span class="n">typing</span><span class="o">.</span><span class="n">Member</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">PointerArg</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">Property</span><span class="p">]</span>
    <span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>The full test is <a class="reference external" href="https://github.com/vercel/python-typemap/blob/main/tests/test_qblike_2.py">in our test suite</a>.</p>
</section>
<section id="pep827-fastapi-impl">
<span id="id2"></span><h3><a class="toc-backref" href="#pep827-fastapi-impl" role="doc-backlink">Automatically deriving FastAPI CRUD models</a></h3>
<p>We have a more <a class="reference external" href="https://github.com/vercel/python-typemap/blob/main/tests/test_fastapilike_2.py">fully-worked example</a> in our test
suite, but here is a possible implementation of just <code class="docutils literal notranslate"><span class="pre">Create</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract the default type from an Init field.</span>
<span class="c1"># If it is a Field, then we try pulling out the &quot;default&quot; field,</span>
<span class="c1"># otherwise we return the type itself.</span>
<span class="nb">type</span> <span class="n">GetDefault</span><span class="p">[</span><span class="n">Init</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">GetFieldItem</span><span class="p">[</span><span class="n">Init</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">Init</span><span class="p">,</span> <span class="n">Field</span><span class="p">]</span>
    <span class="k">else</span> <span class="n">Init</span>
<span class="p">)</span>

<span class="c1"># Create takes everything but the primary key and preserves defaults</span>
<span class="nb">type</span> <span class="n">Create</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">[</span>
    <span class="o">*</span><span class="p">[</span>
        <span class="n">typing</span><span class="o">.</span><span class="n">Member</span><span class="p">[</span>
            <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">p</span><span class="o">.</span><span class="n">quals</span><span class="p">,</span>
            <span class="n">GetDefault</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">init</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span>
            <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
            <span class="n">GetFieldItem</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">init</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;primary_key&quot;</span><span class="p">]],</span>
        <span class="p">]</span>
    <span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Create</span></code> type alias creates a new type (via <code class="docutils literal notranslate"><span class="pre">NewProtocol</span></code>) by
iterating over the attributes of the original type.  It has access to
names, types, qualifiers, and the literal types of initializers (in
part through new facilities to handle the extremely common
<code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">Field(...)</span></code>-like pattern used here).</p>
<p>Here, we filter out attributes that have <code class="docutils literal notranslate"><span class="pre">primary_key=True</span></code> in their
<code class="docutils literal notranslate"><span class="pre">Field</span></code> as well as extracting default arguments (which may be either
from a <code class="docutils literal notranslate"><span class="pre">default</span></code> argument to a field or specified directly as an
initializer).</p>
</section>
<section id="pep827-init-impl">
<span id="id3"></span><h3><a class="toc-backref" href="#pep827-init-impl" role="doc-backlink">dataclasses-style method generation</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">InitFnType</span></code> generates a <code class="docutils literal notranslate"><span class="pre">Member</span></code> for a new <code class="docutils literal notranslate"><span class="pre">__init__</span></code> function
based on iterating over all attributes.</p>
<p><code class="docutils literal notranslate"><span class="pre">GetDefault</span></code> here is borrowed from our FastAPI-like example above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate the Member field for __init__ for a class</span>
<span class="nb">type</span> <span class="n">InitFnType</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Member</span><span class="p">[</span>
    <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;__init__&quot;</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span>
            <span class="n">typing</span><span class="o">.</span><span class="n">Param</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;self&quot;</span><span class="p">],</span> <span class="n">Self</span><span class="p">],</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="n">typing</span><span class="o">.</span><span class="n">Param</span><span class="p">[</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                    <span class="c1"># All arguments are keyword-only</span>
                    <span class="c1"># It takes a default if a default is specified in the class</span>
                    <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;keyword&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span>
                        <span class="n">GetDefault</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">init</span><span class="p">],</span>
                        <span class="n">Never</span><span class="p">,</span>
                    <span class="p">]</span>
                    <span class="k">else</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;keyword&quot;</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
            <span class="p">],</span>
        <span class="p">],</span>
        <span class="kc">None</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ClassVar&quot;</span><span class="p">],</span>
<span class="p">]</span>
<span class="nb">type</span> <span class="n">AddInit</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">[</span>
    <span class="n">InitFnType</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
    <span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Members</span><span class="p">[</span><span class="n">T</span><span class="p">]]],</span>
<span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">UpdateClass</span></code> can then be used to create a class decorator (a la
<code class="docutils literal notranslate"><span class="pre">&#64;dataclass</span></code>) adds a new <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method to a class.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">dataclass_ish</span><span class="p">[</span><span class="n">T</span><span class="p">](</span>
    <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">UpdateClass</span><span class="p">[</span>
    <span class="c1"># Add the computed __init__ function</span>
    <span class="n">InitFnType</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
<span class="p">]:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Or to create a base class (a la Pydantic) that does.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Model</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">[</span><span class="n">T</span><span class="p">](</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="o">.</span><span class="n">UpdateClass</span><span class="p">[</span>
        <span class="c1"># Add the computed __init__ function</span>
        <span class="n">InitFnType</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
    <span class="p">]:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="numpy-style-broadcasting">
<h3><a class="toc-backref" href="#numpy-style-broadcasting" role="doc-backlink">NumPy-style broadcasting</a></h3>
<p>One of the motivations for the introduction of <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> in
<a class="pep reference internal" href="../pep-0646/" title="PEP 646 – Variadic Generics">PEP 646</a> is to represent the shapes of multi-dimensional
arrays, such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="mi">480</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">640</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Array</span><span class="p">()</span>
</pre></div>
</div>
<p>The example in that PEP shows how <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> can be used to
make sure that both sides of an arithmetic operation have matching
shapes. Most multi-dimensional array libraries, however, also support
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.broadcasting.html">broadcasting</a>, which allows the mixing of differently
shaped data.  With this PEP, we can define a <code class="docutils literal notranslate"><span class="pre">Broadcast[A,</span> <span class="pre">B]</span></code> type
alias, and then use it as a return type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">[</span><span class="o">*</span><span class="n">Shape2</span><span class="p">](</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape2</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Broadcast</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape2</span><span class="p">]]]:</span>
        <span class="k">raise</span> <span class="ne">BaseException</span>
</pre></div>
</div>
<p>(The somewhat clunky syntax of wrapping the <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> in
another <code class="docutils literal notranslate"><span class="pre">tuple</span></code> is because typecheckers currently disallow having
two <code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code> arguments. A possible improvement would be to
allow writing the bare (non-starred or <code class="docutils literal notranslate"><span class="pre">Unpack</span></code>-ed) variable name to
mean its interpretation as a tuple.)</p>
<p>We can then do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a1</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">a2</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
<span class="n">a1</span> <span class="o">+</span> <span class="n">a2</span>  <span class="c1"># Array[builtins.float, Literal[4], Literal[3]]</span>

<span class="n">b1</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">b2</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
<span class="n">b1</span> <span class="o">+</span> <span class="n">b2</span>  <span class="c1"># Array[builtins.float, int, int]</span>

<span class="n">err1</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">err2</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">L</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
<span class="c1"># err1 + err2  # E: Broadcast mismatch: Literal[2], Literal[3]</span>
</pre></div>
</div>
<p>Note that this is meant to be an example of the expressiveness of type
manipulation, and not any kind of final proposal about the typing of
tensor types.</p>
<section id="implementation">
<span id="pep827-numpy-impl"></span><h4><a class="toc-backref" href="#implementation" role="doc-backlink">Implementation</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape</span><span class="p">]:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">[</span><span class="o">*</span><span class="n">Shape2</span><span class="p">](</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Shape2</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">[</span><span class="n">DType</span><span class="p">,</span> <span class="o">*</span><span class="n">Broadcast</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="o">*</span><span class="n">Shape2</span><span class="p">]]]:</span>
        <span class="k">raise</span> <span class="ne">BaseException</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">MergeOne</span></code> is the core of the broadcasting operation. If the two types
are equivalent, we take the first, and if either of the types is
<code class="docutils literal notranslate"><span class="pre">Literal[1]</span></code> then we take the other.</p>
<p>On a mismatch, we use the <code class="docutils literal notranslate"><span class="pre">RaiseError</span></code> operator to produce an error
message identifying the two types.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MergeOne</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">T</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsEquivalent</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span> <span class="ow">or</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsEquivalent</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span> <span class="n">S</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsEquivalent</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span> <span class="n">typing</span><span class="o">.</span><span class="n">RaiseError</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;Broadcast mismatch&quot;</span><span class="p">],</span> <span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span>
<span class="p">)</span>

<span class="nb">type</span> <span class="n">DropLast</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Slice</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="nb">type</span> <span class="n">Last</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">GetArg</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">Literal</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

<span class="c1"># Matching on Never here is intentional; it prevents infinite</span>
<span class="c1"># recursions when T is not a tuple.</span>
<span class="nb">type</span> <span class="n">Empty</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Length</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
<p>Broadcast recursively walks down the input tuples applying <code class="docutils literal notranslate"><span class="pre">MergeOne</span></code>
until one of them is empty.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Broadcast</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">S</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">Bool</span><span class="p">[</span><span class="n">Empty</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
    <span class="k">else</span> <span class="n">T</span>
    <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">Bool</span><span class="p">[</span><span class="n">Empty</span><span class="p">[</span><span class="n">S</span><span class="p">]]</span>
    <span class="k">else</span> <span class="nb">tuple</span><span class="p">[</span>
        <span class="o">*</span><span class="n">Broadcast</span><span class="p">[</span><span class="n">DropLast</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">DropLast</span><span class="p">[</span><span class="n">S</span><span class="p">]],</span>
        <span class="n">MergeOne</span><span class="p">[</span><span class="n">Last</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Last</span><span class="p">[</span><span class="n">S</span><span class="p">]],</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="rationale">
<h2><a class="toc-backref" href="#rationale" role="doc-backlink">Rationale</a></h2>
<section id="pep827-callable-rationale">
<span id="id4"></span><h3><a class="toc-backref" href="#pep827-callable-rationale" role="doc-backlink">Extended Callables</a></h3>
<p>We need extended callable support, in order to inspect and produce
callables via type-level computation. mypy supports <a class="reference external" href="https://mypy.readthedocs.io/en/stable/additional_features.html#extended-callable-types">extended
callables</a>
but they are deprecated in favor of callback protocols.</p>
<p>Unfortunately callback protocols don’t work well for type level
computation. (They probably could be made to work, but it would
require a separate facility for creating and introspecting <em>methods</em>,
which wouldn’t be any simpler.)</p>
<dl class="simple">
<dt>We are proposing a fully new extended callable syntax because:</dt><dd><ol class="arabic simple">
<li>The <code class="docutils literal notranslate"><span class="pre">mypy_extensions</span></code> functions are full no-ops, and we need
real runtime objects.</li>
<li>They use parentheses and not brackets, which really goes against
the philosophy here.</li>
<li>We can make an API that more nicely matches what we are going to
do for inspecting members (we could introduce extended callables that
closely mimic the <code class="docutils literal notranslate"><span class="pre">mypy_extensions</span></code> version though, if something new
is a non-starter).</li>
</ol>
</dd>
</dl>
</section>
<section id="pep827-generic-callable-rationale">
<span id="id5"></span><h3><a class="toc-backref" href="#pep827-generic-callable-rationale" role="doc-backlink">Generic Callable</a></h3>
<p>Consider a method with the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="k">if</span> <span class="n">IsAssignable</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="k">else</span> <span class="nb">list</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The type of the method is generic, and the generic is bound at the
<strong>method</strong>, not the class. We need a way to represent such a generic
function as a programmer might write it for a <code class="docutils literal notranslate"><span class="pre">NewProtocol</span></code>.</p>
<p>One option that is somewhat appealing but doesn’t work would be to use
unbound type variables and let them be generalized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Foo</span> <span class="o">=</span> <span class="n">NewProtocol</span><span class="p">[</span>
    <span class="n">Member</span><span class="p">[</span>
        <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;process&quot;</span><span class="p">],</span>
        <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="k">if</span> <span class="n">IsAssignable</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="k">else</span> <span class="n">T</span><span class="p">]</span>
    <span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>The problem is that this is basically incompatible with runtime
evaluation support, since evaluating the alias <code class="docutils literal notranslate"><span class="pre">Foo</span></code> will need to
evaluate the <code class="docutils literal notranslate"><span class="pre">IsAssignable</span></code>, and so we will lose one side of the
conditional at least.  Similar problems will happen when evaluating
<code class="docutils literal notranslate"><span class="pre">Members</span></code> on a class with generic functions.  By wrapping the body
in a lambda, we can delay evaluation in both of these cases.  (The
<code class="docutils literal notranslate"><span class="pre">Members</span></code> case of delaying evaluation works quite nicely for
functions with explicit generic annotations. For old-style generics,
we’ll probably have to try to evaluate it and then raise an error when
we encounter a variable.)</p>
<p>The reason we suggest restricting the use of <code class="docutils literal notranslate"><span class="pre">GenericCallable</span></code> to
the type argument of <code class="docutils literal notranslate"><span class="pre">Member</span></code> is because impredicative
polymorphism (where you can instantiate type variables with other
generic types) and rank-N types (where generics can be bound in nested
positions deep inside function types) are cans of worms when combined
with type inference <a class="footnote-reference brackets" href="#undecidable" id="id6">[1]</a>.  While it would be nice to support,
we don’t want to open that can of worms now.</p>
<p>The unbound type variable tuple is so that bounds and defaults and
<code class="docutils literal notranslate"><span class="pre">TypeVarTuple</span></code>-ness can be specified, though maybe we want to come
up with a new approach.</p>
</section>
</section>
<section id="backwards-compatibility">
<h2><a class="toc-backref" href="#backwards-compatibility" role="doc-backlink">Backwards Compatibility</a></h2>
<p>In the most strict sense, this PEP only proposes new features, and so
shouldn’t have backward compatibility issues.</p>
<p>More loosely speaking, though, the use of <code class="docutils literal notranslate"><span class="pre">if</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span></code> in type
annotations can cause trouble for tools that want to extract type
annotations.</p>
<p>Tools that want to fully evaluate the annotations will need to either
implement an evaluator or use a library for it (the PEP authors are
planning to produce such a library).</p>
<p>Tools that specifically rely on introspecting annotations at runtime
(tools that parse Python files are obviously unaffected) that want
to extract the annotations unevaluated and process them in some way are
possibly in more trouble. Currently, this is
doable if <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> is specified, because
the string annotation could be parsed with <code class="docutils literal notranslate"><span class="pre">ast.parse</span></code> and then handled
in arbitrary ways.</p>
<p>Absent that, as things currently stand, things get trickier, since
there is currently no way to get useful info out of the
<code class="docutils literal notranslate"><span class="pre">__annotate__</span></code> functions without running the annotation, and its
tricks for building a string do not work for loops and
conditionals.</p>
<dl class="simple">
<dt>This could be mitigated by doing one of:</dt><dd><ol class="arabic simple">
<li>The <a class="pep reference internal" href="../pep-0649/#just-store-the-strings" title="PEP 649 – Deferred Evaluation Of Annotations Using Descriptors § “Just store the strings”">“Just store the strings”</a>
option from <a class="pep reference internal" href="../pep-0649/" title="PEP 649 – Deferred Evaluation Of Annotations Using Descriptors">PEP 649</a>, which would allow always extracting
unevaluated strings.</li>
<li>Adding a <code class="docutils literal notranslate"><span class="pre">Format.AST</span></code> mode for
fetching annotations (see this <a class="reference external" href="https://imogenbits-peps.readthedocs.io/en/ast_format/pep-9999/">PEP draft</a>)</li>
</ol>
</dd>
</dl>
<p>If neither of those options is taken, then tools that want to process
unevaluated type manipulation expressions will probably need to
reparse the source code and extract annotations from there. Which we
expect is what most tools do anyway.</p>
</section>
<section id="security-implications">
<h2><a class="toc-backref" href="#security-implications" role="doc-backlink">Security Implications</a></h2>
<p>None are expected.</p>
</section>
<section id="how-to-teach-this">
<h2><a class="toc-backref" href="#how-to-teach-this" role="doc-backlink">How to Teach This</a></h2>
<p>We think much inspiration can be taken from how TypeScript teaches
their equivalent features, since they have similar complexity.  We
will want high-level example-driven documentation, similar to what
TypeScript does.</p>
<p>It is also important to note that the expected audience that will use
the new syntax and APIs are framework and library maintainers who
will be impementing type manipulation to support the advanced patterns
and APIs they introduce.</p>
</section>
<section id="reference-implementation">
<h2><a class="toc-backref" href="#reference-implementation" role="doc-backlink">Reference Implementation</a></h2>
<p>There is a <a class="reference external" href="https://github.com/vercel/python-typemap">demo of a runtime evaluator</a>, which is
also where this PEP draft currently lives.</p>
<p>There is an in-progress <a class="reference external" href="https://github.com/msullivan/mypy/tree/typemap">proof-of-concept implementation</a> in mypy.</p>
<p>It can type check the ORM, FastAPI-style model derivation, and
NumPy-style broadcasting examples.</p>
<p>It is missing support for callables, <code class="docutils literal notranslate"><span class="pre">UpdateClass</span></code>, annotation
processing, and various smaller things.</p>
</section>
<section id="alternate-syntax-ideas">
<h2><a class="toc-backref" href="#alternate-syntax-ideas" role="doc-backlink">Alternate syntax ideas</a></h2>
<p>AKA ‘“Rejected” Ideas That Maybe We Should Actually Do?’</p>
<p>Very interested in feedback about these!</p>
<section id="dictionary-comprehension-based-syntax-for-creating-typed-dicts-and-protocols">
<h3><a class="toc-backref" href="#dictionary-comprehension-based-syntax-for-creating-typed-dicts-and-protocols" role="doc-backlink">Dictionary comprehension based syntax for creating typed dicts and protocols</a></h3>
<p>This is in some ways an extension of the <a class="pep reference internal" href="../pep-0764/" title="PEP 764 – Inline typed dictionaries">PEP 764</a> (still draft)
proposal for inline typed dictionaries.</p>
<p>Combined with the above proposal, using it for <code class="docutils literal notranslate"><span class="pre">NewProtocol</span></code> might
look (using something from <a class="reference internal" href="#pep827-qb-impl"><span class="std std-ref">the query builder example</span></a>)
something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">PropsOnly</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">[</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">PointerArg</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">Property</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Then we would probably also want to allow specifying a <code class="docutils literal notranslate"><span class="pre">Member</span></code> (but
reordered so that <code class="docutils literal notranslate"><span class="pre">Name</span></code> is last and has a default), for if we want
to specify qualifiers and/or an initializer type.</p>
<p>We could also potentially allow qualifiers to be written in the type,
though it is a little odd, since that is an annotation expression, not
a type expression, and you probably <em>wouldn’t</em> be allowed to have an
annotation expression in an arm of a conditional type?</p>
<p>The main downside of this proposal is just complexity: it requires
introducing another kind of weird type form.</p>
<p>We’d also need to figure out the exact interaction between TypedDicts
and new protocols. Would the dictionary syntax always produce a typed
dict, and then <code class="docutils literal notranslate"><span class="pre">NewProtocol</span></code> converts it to a protocol, or would
<code class="docutils literal notranslate"><span class="pre">NewProtocol[&lt;dict</span> <span class="pre">type</span> <span class="pre">expr&gt;]</span></code> be a special form? Would we try to
allow <code class="docutils literal notranslate"><span class="pre">ClassVar</span></code> and <code class="docutils literal notranslate"><span class="pre">Final</span></code>?</p>
<section id="destructuring">
<h4><a class="toc-backref" href="#destructuring" role="doc-backlink">Destructuring?</a></h4>
<p>The other potential “downside” (which might really be an upside!) is
that it suggests that we might want to be able to iterate over
<code class="docutils literal notranslate"><span class="pre">Attrs</span></code> and <code class="docutils literal notranslate"><span class="pre">Members</span></code> with an <code class="docutils literal notranslate"><span class="pre">items()</span></code> style iterator, and that
raises more complicated questions.</p>
<p>First, the syntax would be something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">PropsOnly</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">[</span>
    <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">PointerArg</span><span class="p">[</span><span class="n">ty</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">ty</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">IterItems</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">ty</span><span class="p">,</span> <span class="n">Property</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
<p>This is looking pretty nice, but we only have access to the name and
the type, not the qualifiers or the initializers.</p>
<p>Potential options for dealing with this:</p>
<ul class="simple">
<li>It is fine, programmers can use this <code class="docutils literal notranslate"><span class="pre">.items()</span></code> style
iterator for common cases and operate on full <code class="docutils literal notranslate"><span class="pre">Member</span></code> objects
when they need to.</li>
<li>We can put the qualifiers/initializer in the <code class="docutils literal notranslate"><span class="pre">key</span></code>? Actually using
the name would then require doing <code class="docutils literal notranslate"><span class="pre">key.name</span></code> or similar.</li>
</ul>
<p>(We’d also need to figure out exactly what the rules are for what can
be iterated over this way.)</p>
</section>
</section>
<section id="call-type-operators-using-parens">
<h3><a class="toc-backref" href="#call-type-operators-using-parens" role="doc-backlink">Call type operators using parens</a></h3>
<p>If people are having a bad time in Bracket City, we could also
consider making the built-in type operators use parens instead of
brackets.</p>
<p>Using a mix of <code class="docutils literal notranslate"><span class="pre">[]</span></code> and <code class="docutils literal notranslate"><span class="pre">()</span></code> would introduce consistency issues and
will force users to remember which APIs use square brackets and which
use parentheses. Given that the current Python typing revolves around
using brackets we feel strongly that continuing on that path will lead
to a better developer experience.</p>
<p>As an example, here is how mixing <code class="docutils literal notranslate"><span class="pre">()</span></code> and <code class="docutils literal notranslate"><span class="pre">[]</span></code> could look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">PropsOnly</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">(</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">PointerArg</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">(</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">Property</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>(The user-defined type alias <code class="docutils literal notranslate"><span class="pre">PointerArg</span></code> still must be called with
brackets, despite being basically a helper operator.)</p>
</section>
<section id="have-a-general-mechanism-for-dot-notation-accessible-associated-types">
<h3><a class="toc-backref" href="#have-a-general-mechanism-for-dot-notation-accessible-associated-types" role="doc-backlink">Have a general mechanism for dot-notation accessible associated types</a></h3>
<p>The main proposal is currently silent about exactly <em>how</em> <code class="docutils literal notranslate"><span class="pre">Member</span></code>
and <code class="docutils literal notranslate"><span class="pre">Param</span></code> will have associated types for <code class="docutils literal notranslate"><span class="pre">.name</span></code> and <code class="docutils literal notranslate"><span class="pre">.type</span></code>.</p>
<p>We could just make it work for those particular types, or we could
introduce a general mechanism that might look something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@typing</span><span class="o">.</span><span class="n">has_associated_types</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Member</span><span class="p">[</span>
    <span class="n">N</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
    <span class="n">Q</span><span class="p">:</span> <span class="n">MemberQuals</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Never</span><span class="p">,</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Never</span><span class="p">,</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">Never</span>
<span class="p">]:</span>
    <span class="nb">type</span> <span class="n">name</span> <span class="o">=</span> <span class="n">N</span>
    <span class="nb">type</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">T</span>
    <span class="nb">type</span> <span class="n">quals</span> <span class="o">=</span> <span class="n">Q</span>
    <span class="nb">type</span> <span class="n">init</span> <span class="o">=</span> <span class="n">I</span>
    <span class="nb">type</span> <span class="n">definer</span> <span class="o">=</span> <span class="n">D</span>
</pre></div>
</div>
<p>The decorator (or a base class) is needed if we want the dot notation
for the associated types to be able to work at runtime, since we need
to customize the behavior of <code class="docutils literal notranslate"><span class="pre">__getattr__</span></code> on the
<code class="docutils literal notranslate"><span class="pre">typing._GenericAlias</span></code> produced by the class so that it captures
both the type parameters to <code class="docutils literal notranslate"><span class="pre">Member</span></code> and the alias.</p>
<p>(Though possibly we could change the behavior of <code class="docutils literal notranslate"><span class="pre">_GenericAlias</span></code>
itself to avoid the need for that.)</p>
</section>
</section>
<section id="rejected-ideas">
<h2><a class="toc-backref" href="#rejected-ideas" role="doc-backlink">Rejected Ideas</a></h2>
<section id="renounce-all-cares-of-runtime-evaluation">
<h3><a class="toc-backref" href="#renounce-all-cares-of-runtime-evaluation" role="doc-backlink">Renounce all cares of runtime evaluation</a></h3>
<p>This would give us more flexibility to experiment with syntactic
forms, and would allow us to dispense with some ugliness such as
requiring <code class="docutils literal notranslate"><span class="pre">typing.Iter</span></code> in unpacked comprehension types and having a
limited set of <code class="docutils literal notranslate"><span class="pre">&lt;type-bool&gt;</span></code> expressions that can appear in
conditional types.</p>
<p>For better or worse, though, runtime use of type annotations is
widespread, e.g. <code class="docutils literal notranslate"><span class="pre">pydantic</span></code> depends on it, and one of our motivating
examples (automatically deriving FastAPI CRUD models) depends on it too.</p>
</section>
<section id="support-typescript-style-pattern-matching-in-subtype-checking">
<h3><a class="toc-backref" href="#support-typescript-style-pattern-matching-in-subtype-checking" role="doc-backlink">Support TypeScript style pattern matching in subtype checking</a></h3>
<p>In TypeScript, conditional types are formed like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SomeType extends OtherType ? TrueType : FalseType
</pre></div>
</div>
<p>What’s more, the right-hand side of the check allows binding type
variables based on pattern matching, using the <code class="docutils literal notranslate"><span class="pre">infer</span></code> keyword, like
this example that extracts the element type of an array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>type ArrayArg&lt;T&gt; = T extends [infer El] ? El : never;
</pre></div>
</div>
<p>This is a very elegant mechanism, especially in the way that it
eliminates the need for <code class="docutils literal notranslate"><span class="pre">typing.GetArg</span></code> and its subtle <code class="docutils literal notranslate"><span class="pre">Base</span></code>
parameter.</p>
<p>Unfortunately it seems very difficult to shoehorn into Python’s
existing syntax in any sort of satisfactory way, especially because of
the subtle binding structure.</p>
<p>Perhaps the most plausible variant would be something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">ArrayArg</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">El</span> <span class="k">if</span> <span class="n">IsAssignable</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Infer</span><span class="p">[</span><span class="n">El</span><span class="p">]]]</span> <span class="k">else</span> <span class="n">Never</span>
</pre></div>
</div>
<p>Then, if we wanted to evaluate it at runtime, we’d need to do
something gnarly involving a custom <code class="docutils literal notranslate"><span class="pre">globals</span></code> environment that
catches the unbound <code class="docutils literal notranslate"><span class="pre">Infer</span></code> arguments.</p>
<p>Additionally, without major syntactic changes (using type operators
instead of ternary), we wouldn’t be able to match TypeScript’s
behavior of lifting the conditional over unions.</p>
</section>
<section id="replace-isassignable-with-something-weaker-than-assignable-to-checking">
<h3><a class="toc-backref" href="#replace-isassignable-with-something-weaker-than-assignable-to-checking" role="doc-backlink">Replace <code class="docutils literal notranslate"><span class="pre">IsAssignable</span></code> with something weaker than “assignable to” checking</a></h3>
<p>Full Python typing assignability checking is not fully implementable
at runtime (in particular, even if all the typeshed types for the
stdlib were made available, checking against protocols will often not
be possible, because class attributes may be inferred and have no visible
presence at runtime).</p>
<p>As proposed, a runtime evaluator will need to be “best effort”,
ideally with the contours of that effort well-documented.</p>
<p>An alternative approach would be to have a weaker predicate as the
core primitive.</p>
<p>One possibility would be a “sub-similarity” check: <code class="docutils literal notranslate"><span class="pre">IsAssignableSimilar</span></code>
would do <em>simple</em> checking of the <em>head</em> of types, essentially,
without looking at type parameters. It would not work with protocols.
It would still lift over unions and would check literals.</p>
<p>We decided it probably was not a good idea to introduce a new notion
that is similar to but not the same as subtyping, and that would need
to either have a long and weird name like <code class="docutils literal notranslate"><span class="pre">IsAssignableSimilar</span></code> or a
misleading short one like <code class="docutils literal notranslate"><span class="pre">IsAssignable</span></code>.</p>
</section>
<section id="don-t-use-dot-notation-to-access-member-components">
<h3><a class="toc-backref" href="#don-t-use-dot-notation-to-access-member-components" role="doc-backlink">Don’t use dot notation to access <code class="docutils literal notranslate"><span class="pre">Member</span></code> components</a></h3>
<p>Earlier versions of this PEP draft omitted the ability to write
<code class="docutils literal notranslate"><span class="pre">m.name</span></code> and similar on <code class="docutils literal notranslate"><span class="pre">Member</span></code> and <code class="docutils literal notranslate"><span class="pre">Param</span></code> components, and
instead relied on helper operators such as <code class="docutils literal notranslate"><span class="pre">typing.GetName</span></code> (that
could be implemented under the hood using <code class="docutils literal notranslate"><span class="pre">typing.GetArg</span></code> or
<code class="docutils literal notranslate"><span class="pre">typing.GetMemberType</span></code>).</p>
<p>The potential advantage here is reducing the number of new constructs
being added to the type language, and avoiding needing to either
introduce a new general mechanism for associated types or having a
special-case for <code class="docutils literal notranslate"><span class="pre">Member</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">PropsOnly</span></code> (from <a class="reference internal" href="#pep827-qb-impl"><span class="std std-ref">the query builder example</span></a>) would
look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">PropsOnly</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">typing</span><span class="o">.</span><span class="n">NewProtocol</span><span class="p">[</span>
    <span class="o">*</span><span class="p">[</span>
        <span class="n">typing</span><span class="o">.</span><span class="n">Member</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">GetName</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">PointerArg</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">GetType</span><span class="p">[</span><span class="n">p</span><span class="p">]]]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iter</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">Attrs</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">IsAssignable</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">GetType</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">Property</span><span class="p">]</span>
    <span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
</section>
<section id="use-type-operators-for-conditional-and-iteration">
<span id="pep827-less-syntax"></span><h3><a class="toc-backref" href="#use-type-operators-for-conditional-and-iteration" role="doc-backlink">Use type operators for conditional and iteration</a></h3>
<dl class="simple">
<dt>Instead of writing:</dt><dd><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tt</span> <span class="pre">if</span> <span class="pre">tb</span> <span class="pre">else</span> <span class="pre">tf</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">*[tres</span> <span class="pre">for</span> <span class="pre">T</span> <span class="pre">in</span> <span class="pre">Iter[ttuple]]</span></code></li>
</ul>
</dd>
<dt>we could use type operator forms like:</dt><dd><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Cond[tb,</span> <span class="pre">tt,</span> <span class="pre">tf]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">UnpackMap[ttuple,</span> <span class="pre">lambda</span> <span class="pre">T:</span> <span class="pre">tres]</span></code></li>
<li>or <code class="docutils literal notranslate"><span class="pre">UnpackMap[ttuple,</span> <span class="pre">T,</span> <span class="pre">tres]</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> must be a declared
<code class="docutils literal notranslate"><span class="pre">TypeVar</span></code></li>
</ul>
</dd>
</dl>
<p>Boolean operations would likewise become operators (<code class="docutils literal notranslate"><span class="pre">Not</span></code>, <code class="docutils literal notranslate"><span class="pre">And</span></code>,
etc).</p>
<p>The advantage of this is that constructing a type annotation never
needs to do non-trivial computation (assuming we also get rid of dot
notation), and thus we don’t need <a class="reference internal" href="#pep827-rt-support"><span class="std std-ref">runtime hooks</span></a> to
support evaluating them.</p>
<p>It would also mean that it would be much easier to extract the raw
type annotation.  (The lambda form would still be somewhat fiddly.
The non-lambda form would be trivial to extract, but requiring the
declaration of a <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> goes against the grain of recent
changes.)</p>
<p>Another advantage is not needing any notion of a special
<code class="docutils literal notranslate"><span class="pre">&lt;type-bool&gt;</span></code> class of types.</p>
<p>The disadvantage is that the syntax seems a <em>lot</em>
worse. Supporting filtering while mapping would make it even more bad
(maybe an extra argument for a filter?)</p>
<p>We can explore other options too if needed.</p>
</section>
<section id="perform-type-manipulations-with-normal-python-functions">
<h3><a class="toc-backref" href="#perform-type-manipulations-with-normal-python-functions" role="doc-backlink">Perform type manipulations with normal Python functions</a></h3>
<p>One suggestion has been, instead of defining a new type language
fragment for type-level manipulations, to support calling (some subset
of) Python functions that serve as kind-of “mini-mypy-plugins”.</p>
<p>The main advantage (in our view) here would be leveraging a more
familiar execution model.</p>
<p>One suggested advantage is that it would be a simplification of the
proposal, but we feel that the simplifications promised by the idea
are mostly a mirage, and that calling Python functions to manipulate
types would be quite a bit <em>more</em> complicated.</p>
<p>It would require a well-defined and safe-to-run subset of the language
(and standard library) to be defined that could be run from within
typecheckers. Subsets like this have been defined in other systems
(see <a class="reference external" href="https://starlark-lang.org/">Starlark</a>, the configuration language for Bazel),
but it’s still a lot of surface area, and programmers would need to
keep in mind its boundaries.</p>
<p>Additionally there would need to be a clear specification of how types
are represented in the “mini-plugin” functions, as well as defining
functions/methods for performing various manipulations. Those
functions would have a pretty big overlap with what this PEP currently
proposes.</p>
<p>If runtime use is desired, then either the type representation would
need to be made compatible with how <code class="docutils literal notranslate"><span class="pre">typing</span></code> currently works or we’d
need to have two different runtime type representations.</p>
<p>Whether it would improve the syntax is more up for debate; we think
that adopting some of the syntactic cleanup ideas discussed above (but
not yet integrated into the main proposal) would improve the syntactic
situation at lower cost.</p>
</section>
<section id="make-the-type-level-operations-more-strictly-typed">
<span id="pep827-strict-kinds"></span><h3><a class="toc-backref" href="#make-the-type-level-operations-more-strictly-typed" role="doc-backlink">Make the type-level operations more “strictly-typed”</a></h3>
<p>This proposal is less “strictly-typed” than TypeScript
(strictly-kinded, maybe?).</p>
<p>TypeScript has better typechecking at the alias definition site:
For <code class="docutils literal notranslate"><span class="pre">P[K]</span></code>, <code class="docutils literal notranslate"><span class="pre">K</span></code> needs to have <code class="docutils literal notranslate"><span class="pre">keyof</span> <span class="pre">P</span></code>. The <code class="docutils literal notranslate"><span class="pre">extends</span></code>
conditional type operator narrows the type to help spuport this.</p>
<p>We could do potentially better but it would require quite a bit more
machinery.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">KeyOf[T]</span></code> - literal keys of <code class="docutils literal notranslate"><span class="pre">T</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">Member[T]</span></code>, when statically checking a type alias, could be
treated as having some type like <code class="docutils literal notranslate"><span class="pre">tuple[Member[KeyOf[T],</span> <span class="pre">object,</span>
<span class="pre">str,</span> <span class="pre">...,</span> <span class="pre">...],</span> <span class="pre">...]</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">GetMemberType[T,</span> <span class="pre">S:</span> <span class="pre">KeyOf[T]]</span></code> - but this isn’t supported yet.
TypeScript supports it.</li>
<li>We would also need to do context sensitive type bound inference</li>
</ul>
</section>
</section>
<section id="potential-future-extensions">
<h2><a class="toc-backref" href="#potential-future-extensions" role="doc-backlink">Potential Future Extensions</a></h2>
<section id="support-manipulating-annotated">
<h3><a class="toc-backref" href="#support-manipulating-annotated" role="doc-backlink">Support Manipulating Annotated</a></h3>
<p>Libraries like FastAPI use annotations heavily, and we would like to
be able to use annotations to drive type-level computation decision
making.</p>
<p>Note that currently <code class="docutils literal notranslate"><span class="pre">Annotated</span></code> may be fully ignored by
typecheckers, and so supporting inspection and manipulation of it
could end up being fraught.</p>
<p>One potential API for this might be:</p>
<ul>
<li><code class="docutils literal notranslate"><span class="pre">GetAnnotations[T]</span></code> - Fetch the annotations of a potentially
Annotated type, as Literals. Examples:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GetAnnotations</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;xxx&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;xxx&#39;</span><span class="p">]</span>
<span class="n">GetAnnotations</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;xxx&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;xxx&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">GetAnnotations</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">Never</span>
</pre></div>
</div>
</li>
<li><code class="docutils literal notranslate"><span class="pre">DropAnnotations[T]</span></code> - Drop the annotations of a potentially
Annotated type. Examples:<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DropAnnotations</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;xxx&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">int</span>
<span class="n">DropAnnotations</span><span class="p">[</span><span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;xxx&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">int</span>
<span class="n">DropAnnotations</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span>
</pre></div>
</div>
</li>
</ul>
<section id="string-manipulation">
<h4><a class="toc-backref" href="#string-manipulation" role="doc-backlink">String manipulation</a></h4>
<p>TypeScript has “template literal” types for strings that allow both
concatenating string literal types and decomposing them. They also
have a suite of capitalization related operations.</p>
<p>Supporting concatenation would allow use-cases such as generating new
method names based on attributes: for every attribute <code class="docutils literal notranslate"><span class="pre">foo</span></code> we could
generate a <code class="docutils literal notranslate"><span class="pre">get_foo</span></code> method.</p>
<p>Supporting slicing would allow doing more in-depth string traversals,
and supporting capitalization would allow operations like transforming
a name from <code class="docutils literal notranslate"><span class="pre">snake_case</span></code> to <code class="docutils literal notranslate"><span class="pre">CapitalizedWords</span></code>.</p>
<p>We can actually implement the case functions in terms of them and a
bunch of conditionals, but shouldn’t (especially if we want it to work
for all unicode!).</p>
<p>It would definitely be possible to take just slicing and
concatenation, also.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Slice[S:</span> <span class="pre">Literal[str],</span> <span class="pre">Start:</span> <span class="pre">Literal[int</span> <span class="pre">|</span> <span class="pre">None],</span> <span class="pre">End:</span> <span class="pre">Literal[int</span> <span class="pre">|</span> <span class="pre">None]]</span></code>:
Also support slicing string types. (Currently tuples are supported.)</li>
<li><code class="docutils literal notranslate"><span class="pre">Concat[S1:</span> <span class="pre">Literal[str],</span> <span class="pre">S2:</span> <span class="pre">Literal[str]]</span></code>: concatenate two strings</li>
<li><code class="docutils literal notranslate"><span class="pre">Uppercase[S:</span> <span class="pre">Literal[str]]</span></code>: uppercase a string literal</li>
<li><code class="docutils literal notranslate"><span class="pre">Lowercase[S:</span> <span class="pre">Literal[str]]</span></code>: lowercase a string literal</li>
<li><code class="docutils literal notranslate"><span class="pre">Capitalize[S:</span> <span class="pre">Literal[str]]</span></code>: capitalize a string literal</li>
<li><code class="docutils literal notranslate"><span class="pre">Uncapitalize[S:</span> <span class="pre">Literal[str]]</span></code>: uncapitalize a string literal</li>
</ul>
<p>All of the operators in this section are <a class="reference internal" href="#pep827-lifting"><span class="std std-ref">lifted over union types</span></a>.</p>
</section>
<section id="newprotocolwithbases">
<h4><a class="toc-backref" href="#newprotocolwithbases" role="doc-backlink">NewProtocolWithBases</a></h4>
<p>It would sometimes be useful to support something like
<code class="docutils literal notranslate"><span class="pre">NewProtocolWithBases</span></code>, with a specification like:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">NewProtocolWithBases[Bases:</span> <span class="pre">tuple[type],</span> <span class="pre">*Ms:</span> <span class="pre">Member]</span></code></li>
</ul>
<p>The idea is that a type would satisfy this protocol if it extends all
of the given bases and has the specified members.</p>
<p>This would be useful in situations where we want to do something like
creating a new Pydantic model.</p>
<p>We are holding off from fully proposing this at this time because
protocol-with-bases would be an addition to what protocols can be that
we don’t want to tangle with yet, and because many use cases can be
simulated in other ways.</p>
</section>
</section>
</section>
<section id="open-issues">
<h2><a class="toc-backref" href="#open-issues" role="doc-backlink">Open Issues</a></h2>
<ul>
<li>What invalid operations should be errors and what should return <code class="docutils literal notranslate"><span class="pre">Never</span></code>?</li>
<li><a class="reference internal" href="#pep827-unpack-kwargs"><span class="std std-ref">Unpack of typevars for **kwargs</span></a>: Should
whether we try to infer literal types for extra arguments be
configurable in the <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> serving as the bound somehow? If
<code class="docutils literal notranslate"><span class="pre">readonly</span></code> had been added as a parameter to <code class="docutils literal notranslate"><span class="pre">TypedDict</span></code> we would
use that, but it wasn’t.</li>
<li><a class="reference internal" href="#pep827-extended-callables-prereq"><span class="std std-ref">Extended Callables</span></a>: Should the extended
argument list be wrapped in a <code class="docutils literal notranslate"><span class="pre">typing.Parameters[*Params]</span></code> type (that
will also kind of serve as a bound for <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>)?</li>
<li><a class="reference internal" href="#pep827-extended-callables-prereq"><span class="std std-ref">Extended Callables</span></a>: Currently the
qualifiers are short strings for code brevity, but an alternate approach
would be to mirror <code class="docutils literal notranslate"><span class="pre">inspect.Signature</span></code> more directly, and have an enum
with names like <code class="docutils literal notranslate"><span class="pre">ParamKind.POSITIONAL_OR_KEYWORD</span></code>. Would that be better?<p>A related potential change would be to fully separate the kind from whether
there is a default, and have whether there is a default represented in
an <code class="docutils literal notranslate"><span class="pre">init</span></code> field, like we do for class member initializers with <code class="docutils literal notranslate"><span class="pre">Member</span></code>.</p>
</li>
<li><a class="reference internal" href="#pep827-generic-callable"><span class="std std-ref">Generic Callable</span></a>: Should we have any mechanisms
to inspect/destruct <code class="docutils literal notranslate"><span class="pre">GenericCallable</span></code>? Maybe can fetch the variable
information and maybe can apply it to concrete types?</li>
<li><a class="reference internal" href="#pep827-update-class"><span class="std std-ref">Update class</span></a>: <code class="docutils literal notranslate"><span class="pre">UpdateClass</span></code> introduces
type-evaluation-order dependence; if the <code class="docutils literal notranslate"><span class="pre">UpdateClass</span></code> return type for
some <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code> inspects some unrelated class’s <code class="docutils literal notranslate"><span class="pre">Members</span></code>,
and that class also has an <code class="docutils literal notranslate"><span class="pre">__init_subclass__</span></code>, then the results might
depend on what order they are evaluated. Ideally this kind of case would be
rejected. This does actually exactly mirror a potential <strong>runtime</strong>
evaluation-order dependence, though.</li>
<li>Because of generic functions, there will be plenty of cases where we
can’t evaluate a type operator (because it’s applied to an unresolved
type variable), and exactly what the type evaluation rules should be
in those cases is somewhat unclear.<p>Currently, in the proof of concept implementation in mypy, stuck type
evaluations implement subtype checking fully invariantly: we check
that the operators match and that every operand matches in both
arguments invariantly.</p>
</li>
</ul>
</section>
<section id="acknowledgements">
<h2><a class="toc-backref" href="#acknowledgements" role="doc-backlink">Acknowledgements</a></h2>
<p>We’d like to thank Jukka Lehtosalo, for many discussions about the design.</p>
<p>We’d also like to thank the TypeScript team for their language’s
substantial influence on this proposal!</p>
</section>
<section id="footnotes">
<h2><a class="toc-backref" href="#footnotes" role="doc-backlink">Footnotes</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="undecidable" role="doc-footnote">
<dt class="label" id="undecidable">[<a href="#id6">1</a>]</dt>
<dd></aside>
</aside>
<ul>
<li>“Partial polymorphic type inference is undecidable” by Hans Boehm: <a class="reference external" href="https://dl.acm.org/doi/10.1109/SFCS.1985.44">https://dl.acm.org/doi/10.1109/SFCS.1985.44</a></li>
<li>“On the Undecidability of Partial Polymorphic Type Reconstruction” by Frank Pfenning: <a class="reference external" href="https://www.cs.cmu.edu/~fp/papers/CMU-CS-92-105.pdf">https://www.cs.cmu.edu/~fp/papers/CMU-CS-92-105.pdf</a><p>Our setting does not try to infer generic types for functions,
though, which might dodge some of the problems. On the other hand,
we have subtyping. (Honestly we are already pretty deep into some
of these cans of worms.)</p>
</li>
</ul>
</section>
<section id="copyright">
<h2><a class="toc-backref" href="#copyright" role="doc-backlink">Copyright</a></h2>
<p>This document is placed in the public domain or under the
CC0-1.0-Universal license, whichever is more permissive.</p>
</section>
</section>
<hr class="docutils" />
<p>Source: <a class="reference external" href="https://github.com/python/peps/blob/main/peps/pep-0827.rst">https://github.com/python/peps/blob/main/peps/pep-0827.rst</a></p>
<p>Last modified: <a class="reference external" href="https://github.com/python/peps/commits/main/peps/pep-0827.rst">2026-03-01 22:36:06 GMT</a></p>

        </article>
        <nav id="pep-sidebar">
            <div id="search"></div>
            <h2>Contents</h2>
            <ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#motivation">Motivation</a><ul>
<li><a class="reference internal" href="#prisma-style-orms">Prisma-style ORMs</a></li>
<li><a class="reference internal" href="#automatically-deriving-fastapi-crud-models">Automatically deriving FastAPI CRUD models</a></li>
<li><a class="reference internal" href="#dataclasses-style-method-generation">dataclasses-style method generation</a></li>
<li><a class="reference internal" href="#more-powerful-decorator-typing">More powerful decorator typing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification-of-some-prerequisites">Specification of Some Prerequisites</a><ul>
<li><a class="reference internal" href="#unpack-of-typevars-for-kwargs">Unpack of typevars for <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code></a></li>
<li><a class="reference internal" href="#extended-callables">Extended Callables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#specification">Specification</a><ul>
<li><a class="reference internal" href="#grammar-specification-of-the-extensions-to-the-type-language">Grammar specification of the extensions to the type language</a><ul>
<li><a class="reference internal" href="#type-booleans">Type booleans</a></li>
<li><a class="reference internal" href="#conditional-types">Conditional types</a></li>
<li><a class="reference internal" href="#unpacked-comprehension">Unpacked comprehension</a></li>
<li><a class="reference internal" href="#type-member-access">Type member access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-operators">Type operators</a><ul>
<li><a class="reference internal" href="#boolean-operators">Boolean operators</a></li>
<li><a class="reference internal" href="#basic-operators">Basic operators</a></li>
<li><a class="reference internal" href="#union-processing">Union processing</a></li>
<li><a class="reference internal" href="#object-inspection">Object inspection</a></li>
<li><a class="reference internal" href="#object-creation">Object creation</a></li>
<li><a class="reference internal" href="#initfield">InitField</a></li>
<li><a class="reference internal" href="#callable-inspection-and-creation">Callable inspection and creation</a></li>
<li><a class="reference internal" href="#generic-callable">Generic Callable</a></li>
<li><a class="reference internal" href="#overloaded-function-types">Overloaded function types</a></li>
<li><a class="reference internal" href="#raise-error">Raise error</a></li>
<li><a class="reference internal" href="#update-class">Update class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lifting-over-unions">Lifting over Unions</a></li>
<li><a class="reference internal" href="#runtime-evaluation-support">Runtime evaluation support</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples-tutorial">Examples / Tutorial</a><ul>
<li><a class="reference internal" href="#pep827-qb-impl">Prisma-style ORMs</a></li>
<li><a class="reference internal" href="#pep827-fastapi-impl">Automatically deriving FastAPI CRUD models</a></li>
<li><a class="reference internal" href="#pep827-init-impl">dataclasses-style method generation</a></li>
<li><a class="reference internal" href="#numpy-style-broadcasting">NumPy-style broadcasting</a><ul>
<li><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#rationale">Rationale</a><ul>
<li><a class="reference internal" href="#pep827-callable-rationale">Extended Callables</a></li>
<li><a class="reference internal" href="#pep827-generic-callable-rationale">Generic Callable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a class="reference internal" href="#security-implications">Security Implications</a></li>
<li><a class="reference internal" href="#how-to-teach-this">How to Teach This</a></li>
<li><a class="reference internal" href="#reference-implementation">Reference Implementation</a></li>
<li><a class="reference internal" href="#alternate-syntax-ideas">Alternate syntax ideas</a><ul>
<li><a class="reference internal" href="#dictionary-comprehension-based-syntax-for-creating-typed-dicts-and-protocols">Dictionary comprehension based syntax for creating typed dicts and protocols</a><ul>
<li><a class="reference internal" href="#destructuring">Destructuring?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#call-type-operators-using-parens">Call type operators using parens</a></li>
<li><a class="reference internal" href="#have-a-general-mechanism-for-dot-notation-accessible-associated-types">Have a general mechanism for dot-notation accessible associated types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-ideas">Rejected Ideas</a><ul>
<li><a class="reference internal" href="#renounce-all-cares-of-runtime-evaluation">Renounce all cares of runtime evaluation</a></li>
<li><a class="reference internal" href="#support-typescript-style-pattern-matching-in-subtype-checking">Support TypeScript style pattern matching in subtype checking</a></li>
<li><a class="reference internal" href="#replace-isassignable-with-something-weaker-than-assignable-to-checking">Replace <code class="docutils literal notranslate"><span class="pre">IsAssignable</span></code> with something weaker than “assignable to” checking</a></li>
<li><a class="reference internal" href="#don-t-use-dot-notation-to-access-member-components">Don’t use dot notation to access <code class="docutils literal notranslate"><span class="pre">Member</span></code> components</a></li>
<li><a class="reference internal" href="#use-type-operators-for-conditional-and-iteration">Use type operators for conditional and iteration</a></li>
<li><a class="reference internal" href="#perform-type-manipulations-with-normal-python-functions">Perform type manipulations with normal Python functions</a></li>
<li><a class="reference internal" href="#make-the-type-level-operations-more-strictly-typed">Make the type-level operations more “strictly-typed”</a></li>
</ul>
</li>
<li><a class="reference internal" href="#potential-future-extensions">Potential Future Extensions</a><ul>
<li><a class="reference internal" href="#support-manipulating-annotated">Support Manipulating Annotated</a><ul>
<li><a class="reference internal" href="#string-manipulation">String manipulation</a></li>
<li><a class="reference internal" href="#newprotocolwithbases">NewProtocolWithBases</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues">Open Issues</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#footnotes">Footnotes</a></li>
<li><a class="reference internal" href="#copyright">Copyright</a></li>
</ul>

            <br>
            <a id="source" href="https://github.com/python/peps/blob/main/peps/pep-0827.rst?plain=1">Page Source (GitHub)</a>
        </nav>
    </section>
    <script src="../_static/colour_scheme.js"></script>
    <script src="../_static/wrap_tables.js"></script>
    <script src="../_static/sticky_banner.js"></script>
    <script src="https://analytics.python.org/js/script.outbound-links.js"
            data-domain="peps.python.org" defer></script>
    <script src="/pagefind/pagefind-ui.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', (event) => {
            // Ranking configuration to boost exact title matches
            const searchOptions = {
                ranking: {
                    termSimilarity: 9.0, // Higher values favor exact matches
                    termFrequency: 0.5, // Lower values reduce penalty for low term frequency
                    pageLength: 0.2, // Lower values reduce the impact of page length
                }
            };

            // Initialize pagefind for either mobile or desktop, not both
            if (window.innerWidth <= 640) {
                new PagefindUI({ element: "#mobile-search", ...searchOptions, showSubResults: false });
            } else {
                new PagefindUI({ element: "#search", ...searchOptions, showSubResults: true });
            }
        });
    </script>
</body>
</html>